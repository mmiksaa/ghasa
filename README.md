
---
<div>

###### 1. Что будет в консоли?

<section>
function sayHi() {
  console.log(name);
  console.log(age);
  var name = "Lydia";
  let age = 21;
}

sayHi();
</section>


- A: Lydia и undefined
- B: Lydia и ReferenceError
- C: ReferenceError и 21
- D: undefined и ReferenceError


#### Ответ: D

<span>
Внутри функции мы сперва определяем переменную name с помощью ключевого слова var. Это означает, что переменная будет поднята (область памяти под переменную будет выделена во время фазы создания) со значением undefined по умолчанию, до тех пора пока исполнение кода не дойдет до строчки, где определяется переменная. Мы еще не определили значение name когда пытаемся вывести её в консоль, поэтому в консоли будет undefined.

Переменные, определенные с помощью let (и const), также поднимаются, но в отличие от var, не <i>инициализируются</i>. Доступ к ним не возможен до тех пор, пока не выполнится строка их определения (инициализации). Это называется "временная мертвая зона". Когда мы пытаемся обратиться к переменным до того момента как они определены, JavaScript выбрасывает исключение ReferenceError.

</span>
</div>

---
<div>

###### 2. Что будет в консоли?

<section>
for (var i = 0; i < 3; i++) {
  setTimeout(() => console.log(i), 1);
}

for (let i = 0; i <section 3; i++) {
  setTimeout(() => console.log(i), 1);
}
</section>


- A: 0 1 2 и 0 1 2
- B: 0 1 2 и 3 3 3
- C: 3 3 3 и 0 1 2


#### Ответ: C

<span>
Из-за очереди событий в JavaScript, функция setTimeout вызывается _после_ того как цикл будет завершен. Так как переменная i в первом цикле была определена с помощью var, она будет глобальной. В цикле мы каждый раз увеличиваем значение i на 1, используя унарный оператор ++. К моменту выполнения функции setTimeout значение i будет равно 3 в первом примере.

Во втором цикле переменная i определена с помощью let. Такие переменные (а также const) имеют блочную область видимости (блок это что угодно между { }). С каждой итерацией i будет иметь новое значение, и каждое значение будет замкнуто в своей области видимости внутри цикла.

</span>
</div>

---
<div>

###### 3. Что будет в консоли?

<section>
const shape = {
  radius: 10,
  diameter() {
    return this.radius * 2;
  },
  perimeter: () => 2 * Math.PI * this.radius
};

shape.diameter();
shape.perimeter();
</section>


- A: 20 и 62.83185307179586
- B: 20 и NaN
- C: 20 и 63
- D: NaN и 63


#### Ответ: B

<span>
Заметь, что diameter это обычная функция, в то время как perimeter это стрелочная функция.

У стрелочных функций значение this указывает на окружающую область видимости, в отличие от обычных функций! Это значит, что при вызове perimeter значение this у этой функции указывает не на объект shape, а на внешнюю область видимости (например, window).

У этого объекта нет ключа radius, поэтому возвращается undefined.

</span>
</div>

---
<div>

###### 4. Что будет в консоли?

<section>
+true;
!"Lydia";
</section>


- A: 1 и false
- B: false и NaN
- C: false и false


#### Ответ: A

<span>
Унарный плюс приводит операнд к числу. true это 1, а false это 0.

Строка 'Lydia' это "истинное" значение. На самом деле мы спрашиваем "является ли это истинное значение ложным"? Ответ: false.

</span>
</div>

---
<div>

###### 5. Что НЕ является валидным?

<section>
const bird = {
  size: "small"
};

const mouse = {
  name: "Mickey",
  small: true
};
</section>


- A: mouse.bird.size
- B: mouse[bird.size]
- C: mouse[bird["size"]]
- D: Все варианты валидны


#### Ответ: A

<span>
В JavaScript все ключи объекта являются строками (кроме Symbol). И хотя мы не _набираем_ их как строки, они всегда преобразовываются к строкам под капотом.

JavaScript интерпретирует (или распаковывает) операторы. При использовании квадратных скобок JS замечает [ и продолжает пока не встретит ]. Только после этого он вычислит то, что находится внутри скобок.

mouse[bird.size]: Сперва определяется bird.size, которое равно "small". mouse["small"] возвращает true.

Но с записью через точку так не происходит. У mouse нет ключа bird. Таким образом, mouse.bird равно undefined. Затем мы запрашиваем ключ size, используя точечную нотацию: mouse.bird.size. Так как mouse.bird это undefined, мы запрашиваем undefined.size. Это не является валидным, и мы получаем ошибку типа Cannot read property "size" of undefined.

</span>
</div>

---

<div>

###### 6. Что будет в консоли?

<section>
let c = { greeting: "Hey!" };
let d;

d = c;
c.greeting = "Hello";
console.log(d.greeting);
</section>


- A: Hello
- B: Hey!
- C: undefined
- D: ReferenceError
- E: TypeError


#### Ответ: A

<span>
В JavaScript все объекты являются _ссылочными_ типами данных.

Сперва переменная c указывает на объект. Затем мы указываем переменной d ссылаться на тот же объект, что и c.

<img src="https://i.imgur.com/ko5k0fs.png" width="200">

Когда ты изменяешь один объект, то изменяются значения всех ссылок, указывающих на этот объект.

</span>
</div>

---
<div>

###### 7. Что будет в консоли?

<section>
let a = 3;
let b = new Number(3);
let c = 3;

console.log(a == b);
console.log(a === b);
console.log(b === c);
</section>


- A: true false true
- B: false false true
- C: true false false
- D: false true true


#### Ответ: C

<span>
new Number() это встроенный конструктор функции. И хотя он выглядит как число, это не настоящее число: у него есть ряд дополнительных фич и это объект.

Оператор == разрешает приведение типов, он проверяет равенство _значений_. Оба значения равны 3, поэтому возвращается true.

При использовании оператора === значение _и_ тип должны быть одинаковыми. Но в нашем случае это не так: new Number() это не число, это **объект**. Оба возвращают false.

</span>
</div>

---
<div>

###### 8. Каким будет результат?

<section>
class Chameleon {
  static colorChange(newColor) {
    this.newColor = newColor;
    return this.newColor;
  }

  constructor({ newColor = "green" } = {}) {
    this.newColor = newColor;
  }
}

const freddie = new Chameleon({ newColor: "purple" });
freddie.colorChange("orange");
</section>


- A: orange
- B: purple
- C: green
- D: TypeError


#### Ответ: D

<span>
Функция colorChange является статичной. Статичные методы не имеют доступа к экземплярам класса. Так как freddie это экземпляр, то статичный метод там не доступен. Поэтому выбрасывается ошибка TypeError.

</span>
</div>

---
<div>

###### 9. Что будет в консоли?

<section>
let greeting;
greetign = {}; // Опечатка!
console.log(greetign);
</section>


- A: {}
- B: ReferenceError: greetign is not defined
- C: undefined


#### Ответ: A

<span>
В консоли выведется объект, потому что мы только что создали пустой объект в глобальном объекте! Когда мы вместо greeting написали greetign, интерпретатор JS на самом деле выполнил global.greetign = {} (или window.greetign = {} в браузере).

Нужно использовать "use strict", чтобы избежать такого поведения. Эта запись поможет быть уверенным в том, что переменная была определена перед тем как ей присвоили значение.

</span>
</div>

---
<div>

###### 10. Что произойдет?

<section>
function bark() {
  console.log("Woof!");
}

bark.animal = "dog";
</section>


- A: Ничего, всё в порядке!
- B: SyntaxError. Нельзя добавлять свойства функциям таким способом.
- C: undefined
- D: ReferenceError


#### Ответ: A

<span>
В JavaScript это возможно, т.к. функции это объекты! (Всё есть объект кроме примитивов).

Функция — это специальный тип объекта, который можно вызвать. Кроме того, функция — это объект со свойствами. Свойство такого объекта нельзя вызвать, так как оно не является функцией.

</span>
</div>

---
<div>

###### 11. Что будет в консоли?

<section>
function Person(firstName, lastName) {
  this.firstName = firstName;
  this.lastName = lastName;
}

const member = new Person("Lydia", "Hallie");
Person.getFullName = function () {
  return ${this.firstName} ${this.lastName};
}

console.log(member.getFullName());
</section>


- A: TypeError
- B: SyntaxError
- C: Lydia Hallie
- D: undefined undefined


#### Ответ: A

<span>
Нельзя добавлять свойства конструктору, как обычному объекту. Если нужно добавить фичу всем объектам, то необходимо использовать прототипы. В данном случае

</section>js
Person.prototype.getFullName = function () {
  return ${this.firstName} ${this.lastName};
}
</section>

сделает метод member.getFullName() рабочим. В чем тут преимущество? Предположим, что мы добавили этот метод к конструктору. Возможно, не каждому экземпляру Person нужен этот метод. Это приведет к большим потерям памяти, т.к. все экземпляры будут иметь это свойство. Напротив, если мы добавим этот метод только к прототипу, у нас будет только одно место в памяти, к которому смогут обращаться все экземпляры!

</span>
</div>

---
<div>

###### 12. Что будет в консоли?

<section>
function Person(firstName, lastName) {
  this.firstName = firstName;
  this.lastName = lastName;
}

const lydia = new Person("Lydia", "Hallie");
const sarah = Person("Sarah", "Smith");

console.log(lydia);
console.log(sarah);
</section>


- A: Person {firstName: "Lydia", lastName: "Hallie"} и undefined
- B: Person {firstName: "Lydia", lastName: "Hallie"} и Person {firstName: "Sarah", lastName: "Smith"}
- C: Person {firstName: "Lydia", lastName: "Hallie"} и {}
- D:Person {firstName: "Lydia", lastName: "Hallie"} и ReferenceError


#### Ответ: A

<span>
Для sarah мы не использовали ключевое слово new. Использование new приводит к созданию нового объекта. Но без new он указывает на **глобальный объект**!

Мы указали, что this.firstName равно "Sarah" и this.lastName равно "Smith". На самом деле мы определили global.firstName = 'Sarah' и global.lastName = 'Smith'. sarah осталась undefined, поскольку мы не возвращаем значение из функции Person.

</span>
</div>

---
<div>

###### 13. Назовите три фазы распространения событий


- A: Цель > Захват > Всплытие
- B: Всплытие > Цель > Захват
- C: Цель > Всплытие > Захват
- D: Захват > Цель > Всплытие


#### Ответ: D

<span>
Во время фазы **захвата** событие распространяется с элементов родителей до элемента цели. После достижения **цели** начинается фаза **всплытия**.

<img src="https://i.imgur.com/N18oRgd.png" width="200">

</span>
</div>

---
<div>

###### 14. Все объекты имеют прототипы


- A: Да
- B: Нет


#### Ответ: B

<span>
Все объекты имеют прототипы, кроме **базового объекта**. Базовый объект имеет доступ до некоторых методов и свойств, таких как .toString. Именно поэтому мы можем использовать встроенные методы JavaScript! Все эти методы доступны в прототипе. Если JavaScript не может найти метод непосредственно у объекта, он продолжает поиск по цепочке прототипов пока не найдет.

</span>
</div>

---
<div>

###### 15. Каким будет результат?

<section>
function sum(a, b) {
  return a + b;
}

sum(1, "2");
</section>


- A: NaN
- B: TypeError
- C: "12"
- D: 3


#### Ответ: C

<span>
JavaScript это **динамически типизированный язык**: мы не определяем тип переменных. Переменные могут автоматически быть преобразованы из одного типа в другой без нашего участия, что называется _неявным приведением типов_. **Приведение** это преобразование из одного типа в другой.

В этом примере JavaScript сконвертировал число 1 в строку, чтобы операция внутри функции имела смысл и вернула значение. Во время сложения числа (1) и строки ('2') число преобразовывается к строке. Мы можем конкатенировать строки вот так: "Hello" + "World". Таким образом, "1" + "2" возвращает "12".

</span>
</div>

---
<div>

###### 16. Что будет в консоли?

<section>
let number = 0;
console.log(number++);
console.log(++number);
console.log(number);
</section>


- A: 1 1 2
- B: 1 2 2
- C: 0 2 2
- D: 0 1 2


#### Ответ: C

<span>
**Постфиксный** унарный оператор ++:

1. Возвращает значение (0)
2. Инкрементирует значение (теперь число равно 1)

**Префиксный** унарный оператор ++:

1. Инкрементирует значение (число теперь равно 2)
2. Возвращает значение (2)

Результат: 0 2 2.

</span>
</div>

---
<div>

###### 17. Что будет в консоли?

<section>
function getPersonInfo(one, two, three) {
  console.log(one);
  console.log(two);
  console.log(three);
}

const person = "Lydia";
const age = 21;

getPersonInfo${person} is ${age} years old;
</section>


- A: "Lydia" 21 ["", " is ", " years old"]
- B: ["", " is ", " years old"] "Lydia" 21
- C: "Lydia" ["", " is ", " years old"] 21


#### Ответ: B

<span>
При использовании тегированных шаблонных литералов первым аргументом всегда будет массив строковых значений. Оставшимися аргументами будут значения переданных выражений!

</span>
</div>

---
<div>

###### 18. Что будет в консоли?

<section>
function checkAge(data) {
  if (data === { age: 18 }) {
    console.log("Ты взрослый!");
  } else if (data == { age: 18 }) {
    console.log("Ты все еще взрослый.");
  } else {
    console.log(Хмм.. Кажется, у тебя нет возраста.);
  }
}

checkAge({ age: 18 });
</section>


- A: Ты взрослый!
- B: Ты все еще взрослый.
- C: Хмм.. Кажется, у тебя нет возраста.


#### Ответ: C

<span>
В операциях сравнения примитивы сравниваются по их _значениям_, а объекты по _ссылкам_. JavaScript проверяет, чтобы объекты указывали на одну и ту же область памяти.

Сравниваемые объекты в нашем примере не такие: объект, переданный в качестве параметра, указывает на другую область памяти, чем объекты, используемые в сравнениях.

Поэтому { age: 18 } === { age: 18 } и { age: 18 } == { age: 18 } возвращают false.

</span>
</div>

---
<div>

###### 19. Что будет в консоли?

<section>
function getAge(...args) {
  console.log(typeof args);
}

getAge(21);
</section>


- A: "number"
- B: "array"
- C: "object"
- D: "NaN"


#### Ответ: C

<span>
Оператор распространения (...args) возвращает массив с аргументами. Массив это объект, поэтому typeof args возвращает "object".

</span>
</div>

---
<div>

###### 20. Что будет в консоли?

<section>
function getAge() {
  "use strict";
  age = 21;
  console.log(age);
}

getAge();
</section>


- A: 21
- B: undefined
- C: ReferenceError
- D: TypeError


#### Ответ: C

<span>
Используя "use strict", можно быть уверенным, что мы по ошибке не побъявим глобальные переменные. Мы ранее нигде не объявляли переменную age, поэтому с использованием "use strict" возникнет ReferenceError. Без использования "use strict" ошибки не возникнет, а переменная age добавится в глобальный объект.

</span>
</div>

---
<div>

###### 21. Чему будет равно sum?

<section>
const sum = eval("10*10+5");
</section>


- A: 105
- B: "105"
- C: TypeError
- D: "10*10+5"


#### Ответ: A

<span>
eval выполняет код, переданный в виде строки. Если это выражение (как в данном случае), то вычисляется выражение. Выражение 10 * 10 + 5 вернет число 105.

</span>
</div>

---
<div>

###### 22. Как долго будет доступен cool_secret?

<section>
sessionStorage.setItem("cool_secret", 123);
</section>


- A: Всегда, данные не потеряются.
- B: Пока пользователь не закроет вкладку.
- C: Пока пользователь не закроет браузер, а не только вкладку.
- D: Пока пользователь не выключит компьютер.


#### Ответ: B

<span>
Данные, сохраненные в sessionStorage очищаются после закрытия _вкладки_.

При использовании localStorage данные сохраняются навсегда. Очистить их можно, например, используя localStorage.clear().

</span>
</div>

---
<div>

###### 23. Что будет в консоли?

<section>
var num = 8;
var num = 10;

console.log(num);
</section>


- A: 8
- B: 10
- C: SyntaxError
- D: ReferenceError


#### Ответ: B

<span>
С помощью ключевого слова var можно определять сколько угодно переменных с одним и тем же именем. Переменная будет хранить последнее присвоенное значение.

Но такой трюк нельзя проделать с let и const, т.к. у них блочная область видимости.

</span>
</div>

---
<div>

###### 24. Каким будет результат?

<section>
const obj = { 1: "a", 2: "b", 3: "c" };
const set = new Set([1, 2, 3, 4, 5]);

obj.hasOwnProperty("1");
obj.hasOwnProperty(1);
set.has("1");
set.has(1);
</section>


- A: false true false true
- B: false true true true
- C: true true false true
- D: true true true true


#### Ответ: C

<span>
Все ключи объектов (кроме Symbols) являются строками, даже если заданы не в виде строк. Поэтому obj.hasOwnProperty('1') так же возвращает true.

Но это не работает для set. Значения '1' нет в set: set.has('1') возвращает false. Но set.has(1) вернет true.

</span>
</div>

---
<div>

###### 25. Что будет в консоли?

<section>
const obj = { a: "one", b: "two", a: "three" };
console.log(obj);
</section>


- A: { a: "one", b: "two" }
- B: { b: "two", a: "three" }
- C: { a: "three", b: "two" }
- D: SyntaxError


#### Ответ: C

<span>
Если есть два ключа с одинаковым именем, то ключ будет перезаписан. Его позиция сохранится, но значением будет последнее указанное.

</span>
</div>

---
<div>

###### 26. Глобальный контекст исполнения создает две вещи: глобальный объект и this


- A: Да
- B: Нет
- C: Это зависит


#### Ответ: A

<span>
Базовый контекст исполнения это глобальный контекст исполнения: это то, что доступно где угодно в твоем коде.

</span>
</div>

---
<div>

###### 27. Что будет в консоли?

<section>
for (let i = 1; i <section 5; i++) {
  if (i === 3) continue;
  console.log(i);
}
</section>


- A: 1 2
- B: 1 2 3
- C: 1 2 4
- D: 1 3 4


#### Ответ: C

<span>
Оператор continue пропускает итерацию, если условие возвращает true.

</span>
</div>

---
<div>

###### 28. Каким будет результат?

<section>
String.prototype.giveLydiaPizza = () => {
  return "Just give Lydia pizza already!";
};

const name = "Lydia";

name.giveLydiaPizza();
</section>


- A: "Just give Lydia pizza already!"
- B: TypeError: not a function
- C: SyntaxError
- D: undefined


#### Ответ: A

<span>
String это встроенный конструктор, к которому можно добавлять свойства. Я добавила метод к его прототипу. Строки-примитивы автоматически конвертируются к строкам-объектам. Поэтому все строки (строковые объекты) имеют доступ к этому методу!

</span>
</div>

---
<div>

###### 29. Что будет в консоли?

<section>
const a = {};
const b = { key: "b" };
const c = { key: "c" };

a[b] = 123;
a[c] = 456;

console.log(a[b]);
</section>


- A: 123
- B: 456
- C: undefined
- D: ReferenceError


#### Ответ: B

<span>
Ключи объекта автоматически конвертируются в строки. Мы собираемся добавить объект в качестве ключа к объекту a со значением 123.

Тем не менее, когда мы приводим объект к строке, он становится "[object Object]". Таким образом, мы говорим, что a["object Object"] = 123. Потом мы делаем то же самое. c это другой объект, который мы неявно приводим к строке. Поэтому a["object Object"] = 456.

Затем, когда мы выводим a[b], мы имеем в виду a["object Object"]. Мы только что установили туда значение 456, поэтому в результате получаем 456.

</span>
</div>

---
<div>

###### 30. Каким будет результат?

<section>
const foo = () => console.log("First");
const bar = () => setTimeout(() => console.log("Second"));
const baz = () => console.log("Third");

bar();
foo();
baz();
</section>


- A: First Second Third
- B: First Third Second
- C: Second First Third
- D: Second Third First


#### Ответ: B

<span>
Мы вызываем функцию setTimeout первой. Тем не менее, она выводится в консоль последней

Это происходит из-за того, что в браузерах у нас есть не только рантайм движок, но и WebAPI. WebAPI предоставляет нам функцию setTimeout и много других возможностей. Например, DOM.

После того как _коллбек_ отправлен в WebAPI, функция setTimeout (но не коллбек!) вынимается из стека.

<img src="https://i.imgur.com/X5wsHOg.png" width="200">

Теперь вызывается foo, и "First" выводится в консоль.

<img src="https://i.imgur.com/Pvc0dGq.png" width="200">

foo достается из стека, и вызывается baz. "Third" выводится в консоль.

<img src="https://i.imgur.com/WhA2bCP.png" width="200">

WebAPI не может добавлять содержимое в стек когда захочет. Вместо этого он отправляет коллбек-функцию в так называемую _очередь_.

<img src="https://i.imgur.com/NSnDZmU.png" width="200">

Здесь на сцену выходит цикл событий (event loop). **Event loop** проверяет стек и очередь задач. Если стек пустой, то он берет первый элемент из очереди и отправляет его в стек.

<img src="https://i.imgur.com/uyiScAI.png" width="200">

Вызывается bar, в консоль выводится "Second" и эта функция достается из стека.

</span>
</div>

---
<div>

###### 31. Что будет в event.target после клика на кнопку?

</section>html
<div onclick="console.log('first div')">
  <div onclick="console.log('second div')">
    <span onclick="console.log('button')">
      Кликни!
    </span>
  </span>
</div>
</section>


- A: Внешний div
- B: Внутренний div
- C: button
- D: Массив со всеми вложенными элементами


#### Ответ: C

<span>
Целью события является самый глубокий вложенный элемент. Остановить распространение событий можно с помощью event.stopPropagation

</span>
</div>

---
<div>

###### 32. Что будет в консоли после клика по параграфу?

</section>html
<div onclick="console.log('div')">
  <span onclick="console.log('p')">
    Кликни меня!
  </span>
</div>
</section>


- A: p div
- B: div p
- C: p
- D: div


#### Ответ: A

<span>
После клика по p будет выведено p и div. В цикле жизни события есть три фазы: захват, цель и всплытие. По умолчанию обработчики событий выполняются на фазе всплытия (если не установлен параметр useCapture в true). Всплытие идет с самого глубокого элемента вверх.

</span>
</div>

---
<div>

###### 33. Что будет в консоли?

<section>
const person = { name: "Lydia" };

function sayHi(age) {
  console.log(${this.name} is ${age});
}

sayHi.call(person, 21);
sayHi.bind(person, 21);
</section>


- A: undefined is 21 Lydia is 21
- B: function function
- C: Lydia is 21 Lydia is 21
- D: Lydia is 21 function


#### Ответ: D

<span>
В обоих случаях мы передаем объект, на который будет указывать this. Но .call _выполняется сразу же_!

.bind возвращает _копию_ функции, но с привязанным контекстом. Она не выполняется незамедлительно.

</span>
</div>

---
<div>

###### 34. Каким будет результат?

<section>
function sayHi() {
  return (() => 0)();
}

typeof sayHi();
</section>


- A: "object"
- B: "number"
- C: "function"
- D: "undefined"


#### Ответ: B

<span>
Функция sayHi возвращает значение, возвращаемое из немедленно вызываемого функционального выражения (IIFE). Результатом является 0 типа "number".

Для информации: в JS 8 встроенных типов: null, undefined, boolean, number, string, object, symbol и bigint. "function" не является отдельным типом, т.к. функции являются объектами типа "object".
</span>
</div>

---
<div>

###### 35. Какие из этих значений являются "ложными"?

<section>
0;
new Number(0);
("");
(" ");
new Boolean(false);
undefined;
</section>


- A: 0, '', undefined
- B: 0, new Number(0), '', new Boolean(false), undefined
- C: 0, '', new Boolean(false), undefined
- D: Все являются "ложными"


#### Ответ: A

<span>
Есть только шесть "ложных" значений:

- undefined
- null
- NaN
- 0
- '' (пустая строка)
- false

Конструкторы функций, такие как new Number и new Boolean являются "истинными".

</span>
</div>

---
<div>

###### 36. Что будет в консоли

<section>
console.log(typeof typeof 1);
</section>


- A: "number"
- B: "string"
- C: "object"
- D: "undefined"


#### Ответ: B

<span>
typeof 1 возвращает "number".
typeof "number" возвращает "string"

</span>
</div>

---
<div>

###### 37. Что будет в консоли?

<section>
const numbers = [1, 2, 3];
numbers[10] = 11;
console.log(numbers);
</section>


- A: [1, 2, 3, 7 x null, 11]
- B: [1, 2, 3, 11]
- C: [1, 2, 3, 7 x empty, 11]
- D: SyntaxError


#### Ответ: C

<span>
Когда в массив добавляется значение, которое выходит за пределы длины массива, JavaScript создает так называемые "пустые ячейки". На самом деле они имеют значения undefined, но в консоли выводятся так:

[1, 2, 3, 7 x empty, 11]

в зависимости от окружения (может отличаться для браузеров, Node, и т.д.).

</span>
</div>

---
<div>

###### 38. Что будет в консоли?

<section>
(() => {
  let x, y;
  try {
    throw new Error();
  } catch (x) {
    (x = 1), (y = 2);
    console.log(x);
  }
  console.log(x);
  console.log(y);
})();
</section>


- A: 1 undefined 2
- B: undefined undefined undefined
- C: 1 1 2
- D: 1 undefined undefined


#### Ответ: A

<span>
Блок catch получает аргумент x. Это не тот же x, который определен в качестве переменной перед строкой try {

Затем мы присваиваем этому аргументу значение 1 и устанавливаем значение для переменной y. Потом выводим в консоль значение аргумента x, которое равно 1.

За пределами блока catch переменная x все еще undefined, а y равно 2. Когда мы вызываем console.log(x) за пределами блока catch, этот вызов возвращает undefined, а y возвращает 2.

</span>
</div>

---
<div>

###### 39. Всё в JavaScript это


- A: примитив или объект
- B: функция или объект
- C: вопрос с подвохом! только объекты
- D: число или объект


#### Ответ: A

<span>
В JavaScript есть только примитивы и объекты.

Типы примитивов: boolean, null, undefined, bigint, number, string, и symbol.

Отличием примитива от объекта является то, что примитивы не имеют свойств или методов. Тем не менее, 'foo'.toUpperCase() преобразуется в 'FOO' и не вызывает TypeError. Это происходит потому, что при попытке получения свойства или метода у примитива (например, строки), JavaScript неявно обернет примитив объектом, используя один из классов-оберток (например, String), а затем сразу же уничтожит обертку после вычисления выражения. Все примитивы кроме null и undefined ведут себя таким образом.

</span>
</div>

---
<div>

###### 40. Каким будет результат?

<section>
[[0, 1], [2, 3]].reduce(
  (acc, cur) => {
    return acc.concat(cur);
  },
  [1, 2]
);
</section>


- A: [0, 1, 2, 3, 1, 2]
- B: [6, 1, 2]
- C: [1, 2, 0, 1, 2, 3]
- D: [1, 2, 6]


#### Ответ: C

<span>
[1, 2] - начальное значение, с которым инициализируется переменная acc. После первого прохода acc будет равно [1,2], а cur будет [0,1]. После конкатенации результат будет [1, 2, 0, 1].

Затем acc равно [1, 2, 0, 1], а cur равно [2, 3]. После слияния получим [1, 2, 0, 1, 2, 3].

</span>
</div>

---
<div>

###### 41. Каким будет результат?

<section>
!!null;
!!"";
!!1;
</section>


- A: false true false
- B: false false true
- C: false true true
- D: true true false


#### Ответ: B

<span>
null - "ложный". !null возвращает true. !true возвращает false.

"" - "ложный". !"" возвращает true. !true возвращает false.

1 - "истинный". !1 возвращает false. !false возвращает true.

</span>
</div>

---
<div>

###### 42. Что возвращает метод setInterval?

<section>
setInterval(() => console.log("Hi"), 1000);
</section>


- A: уникальный id
- B: указанное количество миллисекунд
- C: переданную функцию
- D: undefined


#### Ответ: A

<span>
Это метод возвращает уникальный id. Этот id может быть использован для очищения интервала с помощью функции clearInterval().

</span>
</div>

---
<div>

###### 43. Каким будет результат?

<section>
[..."Lydia"];
</section>


- A: ["L", "y", "d", "i", "a"]
- B: ["Lydia"]
- C: [[], "Lydia"]
- D: [["L", "y", "d", "i", "a"]]


#### Ответ: A

<span>
Строка является итерируемой сущностью. Оператор распространения преобразовывает каждый символ в отдельный элемент.

</span>
</div>

---
<div>

###### 44. Каким будет результат?

<section>
function* generator(i) {
  yield i;
  yield i * 2;
}

const gen = generator(10);

console.log(gen.next().value);
console.log(gen.next().value);
</section>


- A: [0, 10], [10, 20]
- B: 20, 20
- C: 10, 20
- D: 0, 10 and 10, 20


#### Ответ: C

<span>
Обычные функции не могут быть остановлены на полпути после вызова. Однако функцию генератор можно "остановить" на полпути, а затем продолжить с того места, где она остановилась. Каждый раз, когда в функции-генераторе встречает ключевое слово yield, функция возвращает значение, указанное после него. Обратите внимание, что функция генератора в этом случае не _return_ значение, оно _yields_ значение.

Сначала мы инициализируем функцию генератор с i, равным 10. Мы вызываем функцию генератор, используя метод next (). Когда мы в первый раз вызываем функцию генератора, i равно 10. Он встречает первое ключевое слово yield, получая значение i. Генератор теперь "приостановлен", и 10 выводится в консоль.

Затем мы снова вызываем функцию с помощью метода next (). Она запускается с того места, где остановилась ранее, все еще с i, равным 10. Теперь он встречает следующее ключевое слово yield и возвращает i * 2. i равно 10, поэтому он возвращает 10 * 2, то есть 20. Это приводит к 10, 20.

</span>
</div>

---
<div>

###### 45. Каким будет результат?

<section>
const firstPromise = new Promise((res, rej) => {
  setTimeout(res, 500, "один");
});

const secondPromise = new Promise((res, rej) => {
  setTimeout(res, 100, "два");
});

Promise.race([firstPromise, secondPromise]).then(res => console.log(res));
</section>


- A: "один"
- B: "два"
- C: "два" "один"
- D: "один" "два"


#### Ответ: B

<span>
Когда мы передаем несколько промисов методу Promise.race, он разрешает/отклоняет _первый_ промис, который разрешается/отклоняется. В метод setTimeout мы передаем таймер: 500 мс для первого промиса (firstPromise) и 100 мс для второго промиса (secondPromise). Это означает, что secondPromise разрешается первым со значением 'два'. res теперь содержит значение 'два', которое выводиться в консоль.

</span>
</div>

---
<div>

###### 46. Каким будет результат?

<section>
let person = { name: "Lydia" };
const members = [person];
person = null;

console.log(members);
</section>


- A: null
- B: [null]
- C: [{}]
- D: [{ name: "Lydia" }]


#### Ответ: D

<span>
Сначала мы объявляем переменную person со значением объекта, у которого есть свойство name.

<img src="https://i.imgur.com/TML1MbS.png" width="200">

Затем мы объявляем переменную с именем members. Мы устанавливаем первый элемент этого массива равным значению переменной person. Объекты взаимодействуют посредством _ссылок_ при установке их равными друг другу. Когда вы назначаете ссылку из одной переменной в другую, вы создаете _копию_ этой ссылки. (обратите внимание, что у них _не одинаковые_ ссылки!)

<img src="https://i.imgur.com/FSG5K3F.png" width="300">

Затем мы присваиваем переменной person значение null.

<img src="https://i.imgur.com/sYjcsMT.png" width="300">

Мы изменили только значение переменной person, а не первый элемент в массиве, поскольку этот элемент имеет другую (скопированную) ссылку на объект. Первый элемент в members по-прежнему содержит ссылку на исходный объект. Когда мы выводим в консоль массив members, первый элемент по-прежнему содержит значение объекта, который выводится в консоль.

</span>
</div>

---
<div>

###### 47. Каким будет результат?

<section>
const person = {
  name: "Lydia",
  age: 21
};

for (const item in person) {
  console.log(item);
}
</section>


- A: { name: "Lydia" }, { age: 21 }
- B: "name", "age"
- C: "Lydia", 21
- D: ["name", "Lydia"], ["age", 21]


#### Ответ: B

<span>
С помощью цикла for-in мы можем перебирать ключи объекта, в данном случае name и age. Под капотом ключи объекта являются строками (если они не являются Symbol). В каждом цикле мы устанавливаем значение item равным текущему ключу, по которому он перебирается. Сначала, item равен name, и выводится в консоль. Затем item равен age, который выводится в консоль.

</span>
</div>

---
<div>

###### 48. Каким будет результат?

<section>
console.log(3 + 4 + "5");
</section>


- A: "345"
- B: "75"
- C: 12
- D: "12"


#### Ответ: B

<span>
Ассоциативность операторов - это порядок, в котором компилятор оценивает выражения, слева направо или справа налево. Это происходит только в том случае, если все операторы имеют _одинаковый_ приоритет. У нас есть только один тип оператора: +. Кроме того, ассоциативность слева направо.

3 + 4 оценивается первым. Это приводит к числу 7.

7 + '5' приводит к "75" из-за принуждения. JavaScript преобразует число 7 в строку, см. вопрос 15. Мы можем объединить две строки, используя оператор +. "7" + "5" приводит к "75".

</span>
</div>

---
<div>

###### 49. Какое значение num?

<section>
const num = parseInt("7*6", 10);
</section>


- A: 42
- B: "42"
- C: 7
- D: NaN


#### Ответ: C

<span>
Только первые числа в строке возвращаются. На основе _системы счисления_ (второй аргумент, чтобы указать, к какому типу чисел мы хотим его анализировать: основание 10, шестнадцатеричное, восьмеричное, двоичное и т.д.), ParseInt проверяет, являются ли символы в строке допустимыми. Как только он встречает символ, который не является допустимым числом в основании, он прекращает синтаксический анализ и игнорирует следующие символы.

* не является допустимым числом. Он только разбирает "7" в десятичную 7. num теперь содержит значение 7.

</span>
</div>

---
<div>

###### 50. Каким будет результат?

<section>
[1, 2, 3].map(num => {
  if (typeof num === "number") return;
  return num * 2;
});
</section>


- A: []
- B: [null, null, null]
- C: [undefined, undefined, undefined]
- D: [ 3 x empty ]


#### Ответ: C

<span>
При использовании метода map, значение num равно элементу, над которым он в данный момент зацикливается. В этом случае элементы являются числами, поэтому условие оператора if typeof num === "number" возвращает true. Функция map создает новый массив и вставляет значения, возвращаемые функцией.

Однако мы не возвращаем значение. Когда мы не возвращаем значение из функции, функция возвращает значение undefined. Для каждого элемента в массиве вызывается функциональный блок, поэтому для каждого элемента мы возвращаем undefined.

</span>
</div>

---
<div>

###### 51. Каким будет результат?

<section>
function getInfo(member, year) {
  member.name = "Lydia";
  year = 1998;
}

const person = { name: "Sarah" };
const birthYear = "1997";

getInfo(person, birthYear);

console.log(person, birthYear);
</section>


- A: { name: "Lydia" }, "1997"
- B: { name: "Sarah" }, "1998"
- C: { name: "Lydia" }, "1998"
- D: { name: "Sarah" }, "1997"


#### Ответ: A

<span>
Аргументы передаются _значением_, если их значение не является объектом, то они передаются _ссылкой_. birthYear передается по значению, поскольку это строка, а не объект. Когда мы передаем аргументы по значению, создается _копия_ этого значения (см. вопрос 46).

Переменная birthYear имеет ссылку на значение "1997". Аргумент year также имеет ссылку на значение "1997" , но это не то же самое значение, на которое имеется ссылка для birthYear. Когда мы обновляем значение year, устанавливая year равным "1998", мы обновляем только значение year. birthYear по-прежнему равно "1997".

Значение person является объектом. Аргумент member имеет (скопированную) ссылку на _тот же_ объект. Когда мы изменяем свойство объекта, на который member ссылается, значение person также будет изменено, поскольку они оба имеют ссылку на один и тот же объект. Свойство name объекта person теперь равно значению "Lydia".

</span>
</div>

---
<div>

###### 52. Каким будет результат?

<section>
function greeting() {
  throw "Hello world!";
}

function sayHi() {
  try {
    const data = greeting();
    console.log("It worked!", data);
  } catch (e) {
    console.log("Oh no an error:", e);
  }
}

sayHi();
</section>


- A: It worked! Hello world!
- B: Oh no an error: undefined
- C: SyntaxError: can only throw Error objects
- D: Oh no an error: Hello world!


#### Ответ: D

<span>
С помощью оператора throw мы можем создавать собственные ошибки. С этим оператором вы можете генерировать исключения. Исключением может быть <b>строка</b>, <b>число</b>, <b>логическое значение</b> или <b>объект</b>. В этом случае нашим исключением является строка 'Hello world'.

С помощью оператора catch мы можем указать, что делать, если в блоке try выдается исключение. Исключение: строка 'Hello world'. e теперь равно той строке, которую мы записываем. Это приводит к 'Oh no an error: Hello world'.

</span>
</div>

---
<div>

###### 53. Каким будет результат?

<section>
function Car() {
  this.make = "Lamborghini";
  return { make: "Maserati" };
}

const myCar = new Car();
console.log(myCar.make);
</section>


- A: "Lamborghini"
- B: "Maserati"
- C: ReferenceError
- D: TypeError


#### Ответ: B

<span>
Когда вы возвращаете свойство, значение свойства равно _возвращаемому_ значению, а не значению, установленному в функции конструктора. Мы возвращаем строку "Maserati", поэтому myCar.make равно "Maserati".

</span>
</div>

---
<div>

###### 54. Каким будет результат?

<section>
(() => {
  let x = (y = 10);
})();

console.log(typeof x);
console.log(typeof y);
</section>


- A: "undefined", "number"
- B: "number", "number"
- C: "object", "number"
- D: "number", "undefined"


#### Ответ: A

<span>
let x = y = 10; на самом деле является сокращением для:

<section>
y = 10;
let x = y;
</section>

Когда мы устанавливаем y равным 10, мы фактически добавляем свойство y к глобальному объекту (window в браузере, global в Node). В браузере window.y теперь равен 10.

Затем мы объявляем переменную x со значением y, которое равно 10. Переменные, объявленные с ключевым словом let, имеют _блочную видимость_, они определены только в блоке, в котором они объявлены; немедленно вызванная функция (IIFE) в этом случае. Когда мы используем оператор typeof, операнд x не определен: мы пытаемся получить доступ к x вне блока, в котором он объявлен. Это означает, что x не определен. Значения, которым не присвоено или не объявлено значение, имеют тип "undefined". console.log(typeof x) возвращает "undefined".

Однако мы создали глобальную переменную y, установив y равным 10. Это значение доступно в любом месте нашего кода. y определен и содержит значение типа "number". console.log(typeof y) возвращает "number".

</span>
</div>

---
<div>

###### 55. Какой будет вывод?

<section>
class Dog {
  constructor(name) {
    this.name = name;
  }
}

Dog.prototype.bark = function() {
  console.log(Woof I am ${this.name});
};

const pet = new Dog("Mara");

pet.bark();

delete Dog.prototype.bark;

pet.bark();
</section>


- A: "Woof I am Mara", TypeError
- B: "Woof I am Mara", "Woof I am Mara"
- C: "Woof I am Mara", undefined
- D: TypeError, TypeError


#### Ответ: A

<span>
Мы можем удалить свойства из объектов, используя ключевое слово delete, также в прототипе. Удаляя свойство в прототипе, оно больше не доступно в цепочке прототипов. В этом случае функция bark больше не доступна в прототипе послеdelete Dog.prototype.bark, но мы все еще пытаемся получить к ней доступ.

Когда мы пытаемся вызвать что-то, что не является функцией, выдается TypeError. В этом случае TypeError: pet.bark не является функцией, поскольку pet.bark является undefined.

</span>
</div>

---
<div>

###### 56. Какой будет вывод?

<section>
const set = new Set([1, 1, 2, 3, 4]);

console.log(set);
</section>


- A: [1, 1, 2, 3, 4]
- B: [1, 2, 3, 4]
- C: {1, 1, 2, 3, 4}
- D: {1, 2, 3, 4}


#### Ответ: D

<span>
Объект Set является коллекцией _unique_ значений: значение может появляться только один раз в наборе.

Мы передали последовательность [1, 1, 2, 3, 4] с повторяющимся значением 1. Поскольку в наборе не может быть двух одинаковых значений, одно из них удаляется. Это приводит к {1, 2, 3, 4}.

</span>
</div>

---
<div>

###### 57. Какой будет вывод?

<section>
// counter.js
let counter = 10;
export default counter;
</section>

<section>
// index.js
import myCounter from "./counter";

myCounter += 1;

console.log(myCounter);
</section>


- A: 10
- B: 11
- C: Error
- D: NaN


#### Ответ: C

<span>
Импортированный модуль является _read-only_: вы не можете изменить импортированный модуль. Только модуль, который их экспортирует, может изменить его значение.

Когда мы пытаемся увеличить значение myCounter, выдается ошибка: myCounter доступен только для чтения и не может быть изменен.

</span>
</div>

---
<div>

###### 58. Какой будет вывод?

<section>
const name = "Lydia";
age = 21;

console.log(delete name);
console.log(delete age);
</section>


- A: false, true
- B: "Lydia", 21
- C: true, true
- D: undefined, undefined


#### Ответ: A

<span>
Оператор delete возвращает логическое значение: true при успешном удалении, иначе он вернет false. Однако переменные, объявленные с ключевым словом var, const или let, не могут быть удалены с помощью оператора delete.

Переменная name была объявлена ​​с ключевым словом const, поэтому ее удаление не было успешным: возвращается false. Когда мы устанавливаем age равным 21, мы фактически добавляем свойство с именем age к глобальному объекту. Вы можете успешно удалить свойства из объектов, в том числе из глобального объекта, поэтому delete age возвращает true.

</span>
</div>

---
<div>

###### 59. Какой будет вывод?

<section>
const numbers = [1, 2, 3, 4, 5];
const [y] = numbers;

console.log(y);
</section>


- A: [[1, 2, 3, 4, 5]]
- B: [1, 2, 3, 4, 5]
- C: 1
- D: [1]


#### Ответ: C

<span>
Мы можем распаковать значения из массивов или свойств из объектов путем деструктуризации. Например:

<section>
[a, b] = [1, 2];
</section>

<img src="https://i.imgur.com/ADFpVop.png" width="200">

Значение a теперь равно 1, а значение b теперь равно 2. Что мы на самом деле сделали в этом вопросе, так это:

<section>
[y] = [1, 2, 3, 4, 5];
</section>

<img src="https://i.imgur.com/NzGkMNk.png" width="200">

Это означает, что значение y равно первому значению в массиве, которое является числом 1. Когда мы регистрируем y, возвращается 1.

</span>
</div>

---
<div>

###### 60. Какой будет вывод?

<section>
const user = { name: "Lydia", age: 21 };
const admin = { admin: true, ...user };

console.log(admin);
</section>


- A: { admin: true, user: { name: "Lydia", age: 21 } }
- B: { admin: true, name: "Lydia", age: 21 }
- C: { admin: true, user: ["Lydia", 21] }
- D: { admin: true }


#### Ответ: B

<span>
Можно комбинировать объекты с помощью оператора распространения .... Это позволяет создавать копии пар ключ/значение одного объекта и добавлять их в другой объект. В этом случае мы создаем копии объекта user и добавляем их в объект admin. Объект admin теперь содержит скопированные пары ключ/значение, что приводит к {admin: true, name: "Lydia", age: 21}.

</span>
</div>

---
<div>

###### 61. Какой будет вывод?

<section>
const person = { name: "Lydia" };

Object.defineProperty(person, "age", { value: 21 });

console.log(person);
console.log(Object.keys(person));
</section>


- A: { name: "Lydia", age: 21 }, ["name", "age"]
- B: { name: "Lydia", age: 21 }, ["name"]
- C: { name: "Lydia"}, ["name", "age"]
- D: { name: "Lydia"}, ["age"]


#### Ответ: B

<span>
С помощью метода defineProperty мы можем добавлять новые свойства к объекту или изменять существующие. Когда мы добавляем свойство к объекту с помощью метода defineProperty, они по умолчанию _не перечисляемые_. Метод Object.keys возвращает все имена _enumerable_ свойств объекта, в данном случае только "name".

Свойства, добавленные с помощью метода defineProperty, по умолчанию неизменны. Вы можете переопределить это поведение, используя свойства writable, configurable и enumerable. Таким образом, метод defineProperty дает вам гораздо больший контроль над свойствами, которые вы добавляете к объекту.

</span>
</div>

---
<div>

###### 62. Какой будет вывод?

<section>
const settings = {
  username: "lydiahallie",
  level: 19,
  health: 90
};

const data = JSON.stringify(settings, ["level", "health"]);
console.log(data);
</section>


- A: "{"level":19, "health":90}"
- B: "{"username": "lydiahallie"}"
- C: "["level", "health"]"
- D: "{"username": "lydiahallie", "level":19, "health":90}"


#### Ответ: A

<span>
Второй аргумент JSON.stringify - это _replacer_. Заменитель может быть либо функцией, либо массивом, и позволяет вам контролировать, что и как должны быть преобразованы в значения.

Если заменитель является _массивом_, только свойства, имена которых включены в массив, будут добавлены в строку JSON. В этом случае включаются только свойства с именами "level" и "health", "username" исключается. data теперь равен "{"level":19, "health":90}".

Если заменитель является _function_, эта функция вызывается для каждого свойства объекта, который вы преобразуете. Значение, возвращаемое из этой функции, будет значением свойства при добавлении в строку JSON. Если значение равно undefined, это свойство исключается из строки JSON.

</span>
</div>

---
<div>

###### 63. Какой будет вывод?

<section>
let num = 10;

const increaseNumber = () => num++;
const increasePassedNumber = number => number++;

const num1 = increaseNumber();
const num2 = increasePassedNumber(num1);

console.log(num1);
console.log(num2);
</section>


- A: 10, 10
- B: 10, 11
- C: 11, 11
- D: 11, 12


#### Ответ: A

<span>
Унарный оператор ++ _сначала возвращает_ значение операнда, _затем приращивает_ значение операнда. Значение num1 равно 10, так как функция увеличений вначале возвращает значение num, которое равно 10, и только затем увеличивает значение num.

num2 - это 10, так как мы передали num1 в incpasePassedNumber. number равно 10 (значение num1. Опять же, унарный оператор ++ _сначала возвращает_ значение операнда, _затем увеличивает_ значение операнда. Значение number равно 10, поэтому num2 равно 10.

</span>
</div>

---
<div>

###### 64. Какой будет вывод?

<section>
const value = { number: 10 };

const multiply = (x = { ...value }) => {
  console.log((x.number *= 2));
};

multiply();
multiply();
multiply(value);
multiply(value);
</section>


- A: 20, 40, 80, 160
- B: 20, 40, 20, 40
- C: 20, 20, 20, 40
- D: NaN, NaN, 20, 40


#### Ответ: C

<span>
В ES6 мы можем инициализировать параметры значением по умолчанию. Значением параметра будет значение по умолчанию, если никакое другое значение не было передано функции, или если значение параметра равно "undefined". В этом случае мы распространяем свойства объекта value на новый объект, поэтому значение x по умолчанию равно {number: 10}.

Аргумент по умолчанию реализуется в момент _call time_! Каждый раз, когда мы вызываем функцию, создается _new_ объект. Мы вызываем функцию multiply первые два раза, не передавая значение: x имеет значение по умолчанию {number: 10}. Затем мы записываем умноженное значение этого числа, которое равно 20.

В третий раз, когда мы вызываем multiply, мы передаем аргумент: объект с именем value. Оператор *= на самом деле является сокращением для x.number = x.number * 2: мы изменяем значение x.number и записываем умноженное значение 20.

В четвертый раз мы снова передаем объект value. x.number ранее был изменен на 20, поэтому x.number * = 2 записывает 40.

</span>
</div>

---
<div>

###### 65. Какой будет вывод?

<section>
[1, 2, 3, 4].reduce((x, y) => console.log(x, y));
</section>


- A: 1 2, 3 3 и 6 4
- B: 1 2, 2 3 и 3 4
- C: 1 undefined, 2 undefined, 3 undefined и 4 undefined
- D: 1 2, undefined 3 и undefined 4


#### Ответ: D

<span>
Первым аргументом, который получает метод reduce, является _аккумулятором_, в данном случае x. Второй аргумент - это _текущее значение_, y. С помощью метода reduce мы выполняем функцию обратного вызова для каждого элемента в массиве, что в конечном итоге может привести к единственному значению.

В этом примере мы не возвращаем никаких значений, мы просто регистрируем значения аккумулятора и текущее значение.

Значение аккумулятора равно ранее возвращенному значению функции обратного вызова. Если вы не передадите необязательный аргумент initialValue методу reduce, аккумулятор будет равен первому элементу при первом вызове.

При первом вызове аккумулятор (x) равен 1, а текущее значение (y) равно 2. Мы не возвращаемся из функции обратного вызова, мы регистрируем аккумулятор и текущее значение: 1 и 2 регистрируются.

Если вы не возвращаете значение из функции, она возвращает значение undefined. При следующем вызове аккумулятор равен undefined, а текущее значение равно 3. undefined и 3 будут зарегистрированы.

При четвертом вызове мы снова не возвращаемся из функции обратного вызова. Аккумулятор снова равен undefined, а текущее значение равно 4. undefined и 4 будут зарегистрированы.
</span>
</div>

---
<div>

###### 66. С помощью какого конструктора мы можем успешно расширить класс Dog?

<section>
class Dog {
  constructor(name) {
    this.name = name;
  }
};

class Labrador extends Dog {
  // 1
  constructor(name, size) {
    this.size = size;
  }
  // 2
  constructor(name, size) {
    super(name);
    this.size = size;
  }
  // 3
  constructor(size) {
    super(name);
    this.size = size;
  }
  // 4
  constructor(name, size) {
    this.name = name;
    this.size = size;
  }

};
</section>


- A: 1
- B: 2
- C: 3
- D: 4


#### Ответ: B

<span>
В производном классе вы не можете получить доступ к ключевому слову this до вызова super. Если вы попытаетесь это сделать, он выдаст ReferenceError: 1 и 4 приведут к ошибке ссылки.

С ключевым словом super мы вызываем конструктор родительского класса с заданными аргументами. Конструктор родителя получает аргумент name, поэтому нам нужно передать name в super.

Класс Labrador получает два аргумента: name, поскольку он расширяет Dog, и size в качестве дополнительного свойства класса Labrador. Они оба должны быть переданы в функцию конструктора в Labrador, что делается правильно с помощью конструктора 2.
</span>
</div>

---
<div>

###### 67. Какой будет вывод?

<section>
// index.js
console.log('running index.js');
import { sum } from './sum.js';
console.log(sum(1, 2));

// sum.js
console.log('running sum.js');
export const sum = (a, b) => a + b;
</section>


- A: running index.js, running sum.js, 3
- B: running sum.js, running index.js, 3
- C: running sum.js, 3, running index.js
- D: running index.js, undefined, running sum.js


#### Ответ: B

<span>
С ключевым словом import все импортируемые модули являются _pre-parsed_. Это означает, что импортированные модули запускаются _первыми_, код в файле, который импортирует модуль, исполняется _после_.

В этом разница между require() в CommonJS и import! С помощью require() вы можете загружать зависимости по требованию во время выполнения кода. Если бы мы использовали require вместо import, в консоль были бы записаны running index.js, running sum.js, 3.

</span>
</div>

---
<div>

###### 68. Какой будет вывод?

<section>
console.log(Number(2) === Number(2))
console.log(Boolean(false) === Boolean(false))
console.log(Symbol('foo') === Symbol('foo'))
</section>


- A: true, true, false
- B: false, true, false
- C: true, false, true
- D: true, true, true


#### Ответ: A

<span>
Каждый Symbol совершенно уникален. Цель аргумента, переданного Symbol, состоит в том, чтобы дать Symbol описание. Значение Symbol не зависит от переданного аргумента. Когда мы проверяем равенство, мы создаем два совершенно новых Symbol: первый Symbol('foo') и второй Symbol('foo'). Эти два значения уникальны и не равны друг другу, Symbol('foo') === Symbol('foo') возвращает false.

</span>
</div>

---
<div>

###### 69. Какой будет вывод?

<section>
const name = "Lydia Hallie"
console.log(name.padStart(13))
console.log(name.padStart(2))
</section>


- A: "Lydia Hallie", "Lydia Hallie"
- B: "           Lydia Hallie", "  Lydia Hallie" ("[13x whitespace]Lydia Hallie", "[2x whitespace]Lydia Hallie")
- C: " Lydia Hallie", "Lydia Hallie" ("[1x whitespace]Lydia Hallie", "Lydia Hallie")
- D: "Lydia Hallie", "Lyd",


#### Ответ: C

<span>
С помощью метода padStart мы можем добавить отступ в начало строки. Значение, передаваемое этому методу, представляет собой _общую_ длину строки вместе с отступом. Строка "Lydia Hallie" имеет длину 12. name.padStart(13) вставляет 1 пробел в начале строки, потому что 12 + 1 равно 13.

Если аргумент, переданный методу padStart, меньше длины строки, заполнение не будет добавлено.

</span>
</div>

---
<div>

###### 70. Какой будет вывод?

<section>
console.log("🥑" + "💻");
</section>


- A: "🥑💻"
- B: 257548
- C: Строка, содержащая кодовые обозначения
- D: Error


#### Ответ: A

<span>
С помощью оператора + вы можете объединять строки. В этом случае мы объединяем строку "🥑" со строкой "💻", что приводит к "🥑💻".

</span>
</div>

---
<div>

###### 71. Как мы можем вывести в лог значения, которые закомментированы после оператора console.log?

<section>
function* startGame() {
  const answer = yield "Do you love JavaScript?";
  if (answer !== "Yes") {
    return "Oh wow... Guess we're gone here";
  }
  return "JavaScript loves you back ❤️";
}

const game = startGame();
console.log(/* 1 */); // Do you love JavaScript?
console.log(/* 2 */); // JavaScript loves you back ❤️
</section>


- A: game.next("Yes").value и game.next().value
- B: game.next.value("Yes") и game.next.value()
- C: game.next().value и game.next("Yes").value
- D: game.next.value() и game.next.value("Yes")


#### Ответ: C

<span>
Функция генератора "приостанавливает" выполнение, когда видит ключевое слово yield. Во-первых, мы должны позволить функции выдать строку "Do you love JavaScript?", что можно сделать, вызвав game.next().value.

Каждая строка выполняется до тех пор, пока не найдет первое ключевое слово yield. В первой строке функции есть ключевое слово yield на первом месте: выполнение останавливается с первым выходом! _Это означает, что переменная answer еще не определена!_

Когда мы вызываем game.next("Yes").value, предыдущий yield заменяется значением параметров, переданных функции next(), в данном случае "Yes". Значение переменной answer теперь равно "Yes". Условие if возвращает false, а JavaScript loves you back ❤️, регистрируется.

</span>
</div>

---
<div>

###### 72. Какой будет вывод?

<section>
console.log(String.rawHello\nworld);
</section>


- A: Hello world!
- B: Hello <br />&nbsp; &nbsp; &nbsp;world
- C: Hello\nworld
- D: Hello\n <br /> &nbsp; &nbsp; &nbsp;world


#### Ответ: C

<span>
String.raw возвращает строку, в которой экранированные символы (\n, \v, \t и т.д.) игнорируются! Обратная косая черта может быть проблемой, так как вы можете получить что-то вроде:

 const path = C:\Documents\Projects\table.html 

Что приведет к:

"C:DocumentsProjects able.html"

С String.raw он просто проигнорирует управляющий знак и напечатает:

C:\Documents\Projects\table.html

В этом случае строка Hello\nworld, которая и выводится.

</span>
</div>

---
<div>

###### 73. Какой будет вывод?

<section>
async function getData() {
  return await Promise.resolve("I made it!");
}

const data = getData();
console.log(data);
</section>


- A: "I made it!"
- B: Promise {<resolved>: "I made it!"}
- C: Promise {<pending>}
- D: undefined


#### Ответ: C

<span>
Асинхронная функция всегда возвращает обещание. await все еще должен ждать разрешения обещания: ожидаемое обещание возвращается, когда мы вызываем getData(), чтобы установить data равным ему.

Если бы мы хотели получить доступ к разрешенному значению "I made it", мы могли бы использовать метод .then() для data:

data.then(res => console.log(res))

Тогда это бы вывело "I made it!"

</span>
</div>

---
<div>

###### 74. Какой будет вывод?

<section>
function addToList(item, list) {
  return list.push(item);
}

const result = addToList("apple", ["banana"]);
console.log(result);
</section>


- A: ['apple', 'banana']
- B: 2
- C: true
- D: undefined


#### Ответ: B

<span>
Метод .push() возвращает _длину_ нового массива! Ранее массив содержал один элемент (строка "banana") и имел длину 1. После добавления в массив строки "apple", массив содержит два элемента и имеет длину 2. Это возвращается из функции addToList.

Метод push изменяет исходный массив. Если вы хотите вернуть _массив_ из функции, а не _длину массива_, вы должны были вернуть list после добавления в нее item.

</span>
</div>

---
<div>

###### 75. Какой будет вывод?

<section>
const box = { x: 10, y: 20 };

Object.freeze(box);

const shape = box;
shape.x = 100;

console.log(shape);
</section>


- A: { x: 100, y: 20 }
- B: { x: 10, y: 20 }
- C: { x: 100 }
- D: ReferenceError


#### Ответ: B

<span>
Object.freeze делает невозможным добавление, удаление или изменение свойств объекта (если только значение свойства не является другим объектом).

Когда мы создаем переменную shape и устанавливаем ее равной замороженному объекту box, shape также ссылается на замороженный объект. Вы можете проверить, заморожен ли объект, используя Object.isFrozen. В этом случае Object.isFrozen(shape) возвращает true, поскольку переменная shape имеет ссылку на замороженный объект.

Поскольку shape заморожен, и поскольку значение x не является объектом, мы не можем изменить свойство x. x по-прежнему равно 10, и {x: 10, y: 20} регистрируется.

</span>
</div>

---
<div>

###### 76. Какой будет вывод?

<section>
const { name: myName } = { name: "Lydia" };

console.log(name);
</section>


- A: "Lydia"
- B: "myName"
- C: undefined
- D: ReferenceError


#### Ответ: D

<span>
Когда мы распаковываем свойство name из правого объекта, мы присваиваем его значение "Lydia" переменной с именем myName.

С помощью {name: myName} мы сообщаем JavaScript, что хотим создать новую переменную с именем myName со значением свойства name в правой части.

Поскольку мы пытаемся зарегистрировать name, переменную, которая не определена, выдается ReferenceError.

</span>
</div>

---
<div>

###### 77. Это чистая функция?

<section>
function sum(a, b) {
  return a + b;
}
</section>


- A: Да
- B: Нет


#### Ответ: A

<span>
Чистая функция - это функция, которая всегда возвращает тот же результат, если переданы одинаковые аргументы.

Функция sum всегда возвращает один и тот же результат. Если мы передадим 1 и 2, он всегда вернет 3 без побочных эффектов. Если мы передадим 5 и 10, он всегда вернет 15 и так далее. Это определение чистой функции.

</span>
</div>

---
<div>

###### 78. Какой будет вывод?

<section>
const add = () => {
  const cache = {};
  return num => {
    if (num in cache) {
      return From cache! ${cache[num]};
    } else {
      const result = num + 10;
      cache[num] = result;
      return Calculated! ${result};
    }
  };
};

const addFunction = add();
console.log(addFunction(10));
console.log(addFunction(10));
console.log(addFunction(5 * 2));
</section>


- A: Calculated! 20 Calculated! 20 Calculated! 20
- B: Calculated! 20 From cache! 20 Calculated! 20
- C: Calculated! 20 From cache! 20 From cache! 20
- D: Calculated! 20 From cache! 20 Error


#### Ответ: C

<span>
Функция add является функцией _запоминателем_. С помощью запоминания мы можем кэшировать результаты функции, чтобы ускорить ее выполнение. В этом случае мы создаем объект cache, в котором хранятся ранее возвращенные значения.

Если мы снова вызываем функцию addFunction с тем же аргументом, она сначала проверяет, получило ли оно уже это значение в своем кеше. В этом случае будет возвращено значение кэша, что экономит время выполнения. Иначе, если он не кэшируется, он вычислит значение и сохранит его после.

Мы вызываем функцию addFunction три раза с одним и тем же значением: при первом вызове значение функции, когда num равно 10, еще не кэшировано. Условие оператора if num in cache возвращает false, и выполняется блок else: Calculated! 20 регистрируется, и значение результата добавляется в объект кеша. cache теперь выглядит как {10: 20}.

Во второй раз объект cache содержит значение, возвращаемое для 10. Условие оператора if num in cache возвращает true, а 'From cache! 20' выводится в лог.

В третий раз мы передаем 5 * 2 в функцию, которая оценивается как 10. Объект cache содержит значение, возвращаемое для 10. Условие оператора if num in cache возвращает true, а 'From cache! 20' регистрируется.

</span>
</div>

---
<div>

###### 79. Какой будет вывод?

<section>
const myLifeSummedUp = ["☕", "💻", "🍷", "🍫"]

for (let item in myLifeSummedUp) {
  console.log(item)
}

for (let item of myLifeSummedUp) {
  console.log(item)
}
</section>


- A: 0 1 2 3 и "☕"  "💻" "🍷" "🍫"
- B: "☕"  "💻" "🍷" "🍫" и "☕"  "💻" "🍷" "🍫"
- C: "☕"  "💻" "🍷" "🍫" и 0 1 2 3
- D:  0 1 2 3 и {0: "☕", 1: "💻", 2: "🍷", 3: "🍫"}


#### Ответ: A

<span>
С помощью цикла _for-in_ мы можем перебирать **перечисляемые** свойства. В массиве перечисляемые свойства являются "ключами" элементов массива, которые фактически являются их индексами. Вы можете увидеть массив как:

{0: "☕", 1: "💻", 2: "🍷", 3: "🍫"}

Где ключи - перечисляемые свойства. 0 1 2 3 войти в систему.

С помощью цикла _for-of_ мы можем выполнять итерацию **итераций**. Массив является итеративным. Когда мы выполняем итерацию по массиву, переменная "item" равна элементу, по которому она итерируется в данный момент, "☕" "💻" "🍷" "🍫" выводится в лог.

</span>
</div>

---
<div>

###### 80. Какой будет вывод?

<section>
const list = [1 + 2, 1 * 2, 1 / 2]
console.log(list)
</section>


- A: ["1 + 2", "1 * 2", "1 / 2"]
- B: ["12", 2, 0.5]
- C: [3, 2, 0.5]
- D:  [1, 1, 1]


#### Ответ: C

<span>
Элементы массива могут содержать любые значения. Числа, строки, объекты, другие массивы, ноль, логические значения, неопределенные и другие выражения, такие как даты, функции и вычисления.

Элемент будет равен возвращаемому значению. 1 + 2 вернет 3, 1 * 2 вернет 2, а 1 / 2 вернет 0.5.

</span>
</div>

---
<div>

###### 81. Какой будет вывод?

<section>
function sayHi(name) {
  return Hi there, ${name}
}

console.log(sayHi())
</section>


- A: Hello there, 
- B: Hello there, undefined
- C: Hello there, null
- D:  ReferenceError


#### Ответ: B

<span>
По умолчанию аргументы имеют значение undefined, если только значение не было передано функции. В этом случае мы не передали значение для аргумента name. name равно логгируемому undefined.

В ES6 мы можем перезаписать значение по умолчанию undefined параметрами по умолчанию. Например:

function sayHi(name = "Lydia") { ... }

В этом случае, если мы не передали значение или если мы передали undefined, name всегда будет равно строке Lydia

</span>
</div>

---
<div>

###### 82. Какой будет вывод?

<section>
var status = "😎"

setTimeout(() => {
  const status = "😍"

  const data = {
    status: "🥑",
    getStatus() {
      return this.status
    }
  }

  console.log(data.getStatus())
  console.log(data.getStatus.call(this))
}, 0)
</section>


- A: "🥑" и "😍"
- B: "🥑" и "😎"
- C: "😍" и "😎"
- D: "😎" и "😎"


#### Ответ: B

<span>
Значение ключевого слова this зависит от того, где вы его используете. В **методе**, как и в методе getStatus, ключевое слово this ссылается на объект, которому принадлежит метод. Метод принадлежит объекту data, поэтому this относится к объекту data. Когда мы регистрируем this.status, регистрируется свойство status объекта data, которое является "🥑".

С помощью метода call мы можем изменить объект, на который ссылается ключевое слово this. В **функциях** ключевое слово this относится к _объекту, которому принадлежит функция_. Мы объявили функцию setTimeout для объекта _global_, поэтому в функции setTimeout ключевое слово this ссылается на объект _global_. В глобальном объекте есть переменная с именем _status_ со значением "😎". При регистрации this.status выводится "😎".


</span>
</div>

---
<div>

###### 83. Какой будет вывод?

<section>
const person = {
  name: "Lydia",
  age: 21
}

let city = person.city
city = "Amsterdam"

console.log(person)
</section>


- A: { name: "Lydia", age: 21 }
- B: { name: "Lydia", age: 21, city: "Amsterdam" }
- C: { name: "Lydia", age: 21, city: undefined }
- D: "Amsterdam"


#### Ответ: A

<span>
Мы устанавливаем переменную city равной значению свойства с именем city для объекта person. У этого объекта нет свойства с именем city, поэтому переменная city имеет значение undefined.

Обратите внимание, что мы _не_ ссылаемся на сам объект person! Мы просто устанавливаем переменную city равной текущему значению свойства city объекта person.

Затем мы устанавливаем city равным строке "Amsterdam". Это не меняет объект person - нет ссылки на этот объект.

При регистрации объекта person возвращается неизмененный объект.

</span>
</div>

---
<div>

###### 84. Какой будет вывод?

<section>
function checkAge(age) {
  if (age <section 18) {
    const message = "Sorry, you're too young."
  } else {
    const message = "Yay! You're old enough!"
  }

  return message
}

console.log(checkAge(21))
</section>


- A: "Sorry, you're too young."
- B: "Yay! You're old enough!"
- C: ReferenceError
- D: undefined


#### Ответ: C

<span>
Переменные с ключевыми словами const и let имеют _блочную видимость_. Блок - это что-то между фигурными скобками ({}). В этом случае в фигурных скобках операторов if/else. Вы не можете ссылаться на переменную за пределами блока, в котором она объявлена, вызывается ReferenceError.

</span>
</div>

---
<div>

###### 85. Какая информация будетвыведена в лог?

<section>
fetch('https://www.website.com/api/user/1')
  .then(res => res.json())
  .then(res => console.log(res))
</section>


- A: Результат метода fetch.
- B: Результат второго вызова метода fetch.
- C: Результат коллбэка в предыдущем .then().
- D: Всегда будет undefined.


#### Ответ: C

<span>
Значение res во втором .then равно возвращенному значению предыдущего .then. Вы можете продолжать цепочку .then таким образом; значение передается следующему обработчику.

</span>
</div>

---
<div>

###### 86. Какая опция позволяет установить hasName равным true, если вы не можете передатьtrue в качестве аргумента?

<section>
function getName(name) {
  const hasName = //
}
</section>


- A: !!name
- B: name
- C: new Boolean(name)
- D: name.length


#### Ответ: A

<span>
С помощью !!name мы определяем, является ли значение name истинным или ложным. Если имя истинное, которое мы хотим проверить, то !name возвращает false. А !false (это то, чем на самом деле является !! name) возвращает true.

Устанавливая hasName равным name, вы устанавливаете hasName равным любому значению, которое вы передали функции getName, а не логическому значению true.

new Boolean (true) возвращает объектную оболочку, а не само логическое значение.

name.length возвращает длину переданного аргумента, независимо от того, является ли он true.

</span>
</div>

---
<div>

###### 87. Какой будет вывод?

<section>
console.log("I want pizza"[0])
</section>


- A: """
- B: "I"
- C: SyntaxError
- D: undefined


#### Ответ: B

<span>
Чтобы получить символ по определенному индексу в строке, вы можете использовать скобочную нотацию. Первый символ в строке имеет индекс 0 и т.д. В этом случае мы хотим получить элемент с индексом 0, символ 'I', который выводится в лог.

Обратите внимание, что этот метод не поддерживается в IE7 и ниже. В этом случае используйте .charAt()

</span>
</div>

---
<div>

###### 88. Какой будет вывод?

<section>
function sum(num1, num2 = num1) {
  console.log(num1 + num2)
}

sum(10)
</section>


- A: NaN
- B: 20
- C: ReferenceError
- D: undefined


#### Ответ: B

<span>
Вы можете установить значение параметра по умолчанию равным другому параметру функции, если они были определены _до_ параметров по умолчанию. Мы передаем значение 10 в функцию sum. Если функция sum принимает только один аргумент, это означает, что значение для num2 не передано, и в этом случае значение num1 равно переданному значению 10. Значением по умолчанию num2 является значение num1, которое равно 10. num1 + num2 возвращает 20.

Если вы пытаетесь установить значение параметра по умолчанию равным параметру, который определен _после_ (справа), то значение параметра еще не было инициализировано; это приведет к ошибке.

</span>
</div>

---
<div>

###### 89. Какой будет вывод?

<section>
// module.js
export default () => "Hello world"
export const name = "Lydia"

// index.js
import * as data from "./module"

console.log(data)
</section>


- A: { default: function default(), name: "Lydia" }
- B: { default: function default() }
- C: { default: "Hello world", name: "Lydia" }
- D: Global object of module.js


#### Ответ: A

<span>
С синтаксисом import * as name мы импортируем _все exports_ из файла module.js в файл index.js, тогда и создается новый объект с именем data. В файле module.js есть два экспорта: экспорт по умолчанию и именованный экспорт. Экспорт по умолчанию - это функция, которая возвращает строку "Hello World", а именованный экспорт - это переменная с именем name, которая имеет значение строки "Lydia".

Объект data имеет свойство default для экспорта по умолчанию, другие свойства имеют имена именованных экспортов и их соответствующие значения.

</span>
</div>

---
<div>

###### 90. Какой будет вывод?

<section>
class Person {
  constructor(name) {
    this.name = name
  }
}

const member = new Person("John")
console.log(typeof member)
</section>


- A: "class"
- B: "function"
- C: "object"
- D: "string"


#### Ответ: C

<span>
Классы являются синтаксическим сахаром для конструкторов функций. Эквивалентом класса Person в качестве конструктора функции будет:

<section>
function Person() {
  this.name = name
}
</section>

Вызов конструктора функции с new приводит к созданию экземпляра Person, ключевое слово typeof возвращает "object" для экземпляра. typeof member возвращает "object".

</span>
</div>

---
<div>

###### 91. Какой будет вывод?

<section>
let newList = [1, 2, 3].push(4)

console.log(newList.push(5))
</section>


- A: [1, 2, 3, 4, 5]
- B: [1, 2, 3, 5]
- C: [1, 2, 3, 4]
- D: Error


#### Ответ: D

<span>
Метод .push возвращает _новую длину_ массива, а не сам массив! Устанавливая newList равным [1, 2, 3].push(4), мы устанавливаем newList равным новой длине массива: 4.

Затем мы пытаемся использовать метод .push для newList. Поскольку newList является числовым значением 4, мы не можем использовать метод .push: выдается ошибка TypeError.

</span>
</div>

---
<div>

###### 92. Какой будет вывод?

<section>
function giveLydiaPizza() {
  return "Here is pizza!"
}

const giveLydiaChocolate = () => "Here's chocolate... now go hit the gym already."

console.log(giveLydiaPizza.prototype)
console.log(giveLydiaChocolate.prototype)
</section>


- A: { constructor: ...} { constructor: ...}
- B: {} { constructor: ...}
- C: { constructor: ...} {}
- D: { constructor: ...} undefined


#### Ответ: D

<span>
Обычные функции, такие как функция giveLydiaPizza, имеют свойство prototype, которое является объектом (прототипом объекта) со свойством constructor. Однако функции со стрелками, такие как функция giveLydiaChocolate, не имеют этого свойства prototype. undefined возвращается при попытке доступа к свойству prototype с использованием giveLydiaChocolate.prototype.

</span>
</div>

---
<div>

###### 93. Какой будет вывод?

<section>
const person = {
  name: "Lydia",
  age: 21
}

for (const [x, y] of Object.entries(person)) {
  console.log(x, y)
}
</section>


- A: name Lydia and age 21
- B: ["name", "Lydia"] and ["age", 21]
- C: ["name", "age"] and undefined
- D: Error


#### Ответ: A

<span>
Object.entries (person) возвращает массив вложенных массивов, содержащий ключи и объекты:

[ [ 'name', 'Lydia' ], [ 'age', 21 ] ]

Используя цикл for-of, мы можем перебирать каждый элемент массива, в данном случае подмассивы. Мы можем мгновенно деструктурировать подмассивы в цикле for, используя const [x, y]. x равен первому элементу в подмассиве, y равен второму элементу в подмассиве.

Первым подмассивом является [ "name", "Lydia" ], где x равно "name", и y равно "Lydia", которые выводятся в лог.
Вторым подмассивом является [ "age", 21 ], где x равно "age", и y равно 21, которые выводятся в лог.

</span>
</div>

---
<div>

###### 94. Какой будет вывод?

<section>
function getItems(fruitList, ...args, favoriteFruit) {
  return [...fruitList, ...args, favoriteFruit]
}

getItems(["banana", "apple"], "pear", "orange")
</section>


- A: ["banana", "apple", "pear", "orange"]
- B: [["banana", "apple"], "pear", "orange"]
- C: ["banana", "apple", ["pear"], "orange"]
- D: SyntaxError


#### Ответ: D

<span>
... args - прочие параметры. Значение прочих параметров - это массив, содержащий все оставшиеся аргументы **и может быть передан только последним**! В этом примере прочие параметры были вторым аргументом. Это невозможно, и это приведет к синтаксической ошибке.

<section>
function getItems(fruitList, favoriteFruit, ...args) {
  return [...fruitList, ...args, favoriteFruit]
}

getItems(["banana", "apple"], "pear", "orange")
</section>

Приведенный выше пример работает. Это возвращает массив [ 'banana', 'apple', 'orange', 'pear' ]
</span>
</div>

---
<div>

###### 95. Какой будет вывод?

<section>
function nums(a, b) {
  if
  (a > b)
  console.log('a is bigger')
  else
  console.log('b is bigger')
  return
  a + b
}

console.log(nums(4, 2))
console.log(nums(1, 2))
</section>


- A: a is bigger, 6 and b is bigger, 3
- B: a is bigger, undefined and b is bigger, undefined
- C: undefined and undefined
- D: SyntaxError


#### Ответ: B

<span>
В JavaScript мы _не должны_ явно указывать точку с запятой (;), однако движок JavaScript все равно добавляет их после операторов. Это называется **автоматической вставкой точек с запятой**. Например, оператором могут быть переменные или ключевые слова, такие как throw, return, break и т.д.

Здесь мы написали инструкцию return и другое значение a + b в новой строке. Однако, поскольку это новая линия, движок не знает, что это на самом деле значение, которое мы хотели бы вернуть. Вместо этого он автоматически добавляет точку с запятой после return. Вы можете увидеть это как:

<section>
  return;
  a + b
</section>

Это означает, что a + b никогда не достигается, так как функция перестает выполняться после ключевого слова return. Если значение не возвращается, как здесь, функция возвращает значение undefined. Обратите внимание, что после операторов if / else автоматической вставки нет!

</span>
</div>

---
<div>

###### 96. Какой будет вывод?

<section>
class Person {
  constructor() {
    this.name = "Lydia"
  }
}

Person = class AnotherPerson {
  constructor() {
    this.name = "Sarah"
  }
}

const member = new Person()
console.log(member.name)
</section>


- A: "Lydia"
- B: "Sarah"
- C: Error: cannot redeclare Person
- D: SyntaxError


#### Ответ: B

<span>
Мы можем установить классы равными другим классам/конструкторам функций. В этом случае мы устанавливаем Person равным AnotherPerson. Свойство name этого конструктора - Sarah, поэтому свойство name для нового экземпляра класса Person member - это Sarah.

</span>
</div>

---
<div>

###### 97. Какой будет вывод?

<section>
const info = {
  [Symbol('a')]: 'b'
}

console.log(info)
console.log(Object.keys(info))
</section>


- A: {Symbol('a'): 'b'} and ["{Symbol('a')"]
- B: {} and []
- C: { a: "b" } and ["a"]
- D: {Symbol('a'): 'b'} and []


#### Ответ: D

<span>
Symbol не является _перечисляемый_. Метод Object.keys возвращает все _перечисляемые_ свойства ключа для объекта. Symbol не просматривается таким образом, и возвращается пустой массив. При регистрации всего объекта будут видны все свойства, даже не перечисляемые.

Это одно из многих качеств символа: помимо представления совершенно уникального значения (которое предотвращает случайное столкновение имен в объектах, например, при работе с 2 библиотеками, которые хотят добавить свойства к одному и тому же объекту), вы также можете "скрыть" свойства объектов таким образом (хотя и не полностью. Вы можете получить доступ к символам, используя метод Object.getOwnPropertySymbols()).

</span>
</div>

---
<div>

###### 98. Какой будет вывод?

<section>
const getList = ([x, ...y]) => [x, y]
const getUser = user => { name: user.name, age: user.age }

const list = [1, 2, 3, 4]
const user = { name: "Lydia", age: 21 }

console.log(getList(list))
console.log(getUser(user))
</section>


- A: [1, [2, 3, 4]] and undefined
- B: [1, [2, 3, 4]] and { name: "Lydia", age: 21 }
- C: [1, 2, 3, 4] and { name: "Lydia", age: 21 }
- D: Error and { name: "Lydia", age: 21 }


#### Ответ: A

<span>
Функция getList получает массив в качестве аргумента. Между скобками функции getList мы сразу же деструктурируем этот массив. Вы можете увидеть это как:

 [x, ...y] = [1, 2, 3, 4]

С помощью оставшихся параметров ... y мы помещаем все "оставшиеся" аргументы в массив. Остальные аргументы - это 2, 3 и 4 в этом случае. Значение y является массивом, содержащим все остальные параметры. В этом случае значение x равно 1, поэтому, мы видим в логе [x, y], [1, [2, 3, 4]].

Функция getUser получает объект. В случае функций со стрелками мы не можем писать фигурные скобки, если мы просто возвращаем одно значение. Однако, если вы хотите вернуть _объект_ из стрелочной функции, вы должны написать его в скобках, в противном случае никакое значение не возвращается! Следующая функция вернула бы объект:

</section>const getUser = user => ({ name: user.name, age: user.age })</section>

Поскольку в этом случае значение не возвращается, функция возвращает значение undefined.

</span>
</div>

---
<div>

###### 99. Какой будет вывод?

<section>
const name = "Lydia"

console.log(name())
</section>


- A: SyntaxError
- B: ReferenceError
- C: TypeError
- D: undefined


#### Ответ: C

<span>
Переменная name содержит значение строки, которая не является функцией, поэтому не может вызываться.

Ошибки типа выдаются, когда значение не соответствует ожидаемому типу. JavaScript ожидал, что name будет функцией, так как мы пытаемся вызвать ее. Однако это была строка, поэтому выдается ошибка TypeError: name не является функцией!

Синтаксические ошибки генерируются, когда вы написали что-то, что не является допустимым JavaScript, например, когда вы написали слово return как retrun.
ReferenceErrors генерируется, когда JavaScript не может найти ссылку на значение, к которому вы пытаетесь получить доступ.

</span>
</div>

---
<div>

###### 100. Какое значение будет на выходе?

<section>
// 🎉✨ This is my 100th question! ✨🎉

const output = ${[] && 'Im'}possible!
You should${'' && n't} see a therapist after so much JavaScript lol
</section>


- A: possible! You should see a therapist after so much JavaScript lol
- B: Impossible! You should see a therapist after so much JavaScript lol
- C: possible! You shouldn't see a therapist after so much JavaScript lol
- D: Impossible! You shouldn't see a therapist after so much JavaScript lol


#### Ответ: B

<span>
[] - истинное значение. С оператором && будет возвращено правое значение, если левое значение является истинным значением. В этом случае левое значение [] является истинным значением, поэтому возвращается 'Im'.

"" - ложное значение. Если левое значение ложно, ничего не возвращается. n't не возвращается.

</span>
</div>

---
<div>

###### 101. Какое значение будет на выходе?

<section>
const one = (false || {} || null)
const two = (null || false || "")
const three = ([] || 0 || true)

console.log(one, two, three)
</section>


- A: false null []
- B: null "" true
- C: {} "" []
- D: null null true


#### Ответ: C

<span>
С помощью оператора || мы можем вернуть первый истинный операнд. Если все значения ложны, последний операнд возвращается.

(false || {} || null): пустой объект {} является истинным значением. Это первое (и единственное) истинное значение, которое возвращается. one содержит {}.

(null || false || ""): все операнды являются ложными значениями. Это означает, что прошедший операнд "" возвращается. two содержит "".

([] || 0 || ""): пустой массив [] является истинным значением. Это первое истинное значение, которое возвращается. three присвоено [].

</span>
</div>

---
<div>

###### 102. Какое значение будет на выходе?

<section>
const myPromise = () => Promise.resolve('I have resolved!')

function firstFunction() {
  myPromise().then(res => console.log(res))
  console.log('second')
}

async function secondFunction() {
  console.log(await myPromise())
  console.log('second')
}

firstFunction()
secondFunction()
</section>


- A: I have resolved!, second and I have resolved!, second
- B: second, I have resolved! and second, I have resolved!
- C: I have resolved!, second and second, I have resolved!
- D: second, I have resolved! and I have resolved!, second


#### Ответ: D

<span>
С обещанием мы в основном говорим: "Я хочу выполнить эту функцию и откладываю ее, пока она выполняется, поскольку это может занять некоторое время". Только когда определенное значение разрешено (или отклонено), и когда стек вызовов пуст, я хочу использовать это значение.

Мы можем получить это значение с помощью ключевого слова .then и await в функции async. Хотя мы можем получить значение обещания с помощью .then и await, они работают немного по-разному.

В firstFunction мы (вроде) отложили функцию myPromise во время ее работы, но продолжили выполнение другого кода, в данном случае console.log ('second'). Затем функция разрешается строкой I have resolved, которая затем логируется после того, как она увидела, что стек вызовов пуст.

Используя ключевое слово await в secondFunction, мы буквально приостанавливаем выполнение асинхронной функции до тех пор, пока значение не будет разрешено до перехода на следующую строку.

Это означает, что мы ожидали разрешения myPromise со значением I have resolved, и только когда это произошло, мы перешли к следующей строке: second была выведена в консоль последней.

</span>
</div>

---
<div>

###### 103. Какое значение будет на выходе?

<section>
const set = new Set()

set.add(1)
set.add("Lydia")
set.add({ name: "Lydia" })

for (let item of set) {
  console.log(item + 2)
}
</section>


- A: 3, NaN, NaN
- B: 3, 7, NaN
- C: 3, Lydia2, [object Object]2
- D: "12", Lydia2, [object Object]2


#### Ответ: C

<span>
Оператор + используется не только для добавления числовых значений, но мы также можем использовать его для объединения строк. Всякий раз, когда движок JavaScript видит, что одно или несколько значений не являются числом, он приводит число к строке.

Первым является 1, который является числовым значением. 1 + 2 возвращает число 3.

Тем не менее, вторая строка "Lydia". "Lydia" является строкой, а 2 является числом: 2 приводится к строке. "Lydia" и "2" объединяются, что приводит к результирующей строке "Lydia2".

{name: "Lydia"} является объектом. Ни число, ни объект не являются строкой, поэтому они приводятся к строке. Всякий раз, когда мы приводим обычный объект, он становится "[object Object]". "[object Object]", объединенный с "2", становится "[object Object]2".

</span>
</div>

---
<div>

###### 104. Чему равно значение?

<section>
Promise.resolve(5)
</section>


- A: 5
- B: Promise {<pending>: 5}
- C: Promise {<fulfilled>: 5}
- D: Error


#### Ответ: C

<span>
Мы можем передать любой тип значения, которое мы хотим, в Promise.resolve, либо обещание, либо не обещание. Сам метод возвращает обещание с разрешенным значением (<fulfilled>). Если вы передадите обычную функцию, это будет разрешенное обещание с обычным значением. Если вы передадите обещание, это будет разрешенное обещание с разрешенным значением этого пройденного обещания.

В этом случае мы просто передали числовое значение 5. Возвращается разрешенное обещание со значением 5.

</span>
</div>

---
<div>

###### 105. Чему равно значение?

<section>
function compareMembers(person1, person2 = person) {
  if (person1 !== person2) {
    console.log("Not the same!")
  } else {
    console.log("They are the same!")
  }
}

const person = { name: "Lydia" }

compareMembers(person)
</section>


- A: Not the same!
- B: They are the same!
- C: ReferenceError
- D: SyntaxError


#### Ответ: B

<span>
Объекты передаются по ссылке. Когда мы проверяем объекты на строгое равенство (===), мы сравниваем их ссылки.

Мы устанавливаем значение по умолчанию для person2, равное объекту person, и передаем объект person в качестве значения для person1.

Это означает, что оба значения имеют ссылку на одно и то же место в памяти, поэтому они равны.

Блок кода в операторе else запускается, и в лог выводится They are the same!.

</span>
</div>

---
<div>

###### 106. Чему равно значение?

<section>
const colorConfig = {
  red: true,
  blue: false,
  green: true,
  black: true,
  yellow: false,
}

const colors = ["pink", "red", "blue"]

console.log(colorConfig.colors[1])
</section>


- A: true
- B: false
- C: undefined
- D: TypeError


#### Ответ: D

<span>
В JavaScript у нас есть два способа доступа к свойствам объекта: нотация в скобках или нотация в точках. В этом примере мы используем точечную нотацию (colorConfig.colors) вместо скобочной нотации (colorConfig["colors"]).

В точечной нотации JavaScript пытается найти свойство объекта с таким точным именем. В этом примере JavaScript пытается найти свойство с именем colors в объекте colorConfig. Не существует свойства с именем colors, поэтому возвращается undefined. Затем мы пытаемся получить доступ к значению первого элемента, используя [1]. Мы не можем сделать это для значения, которое undefined, поэтому оно выдает TypeError: Cannot read свойство '1' of undefined.

JavaScript интерпретирует (или распаковывает) операторы. Когда мы используем скобочные обозначения, он видит первую открывающую скобку [ и продолжает работать, пока не найдет закрывающую скобку ]. Только тогда он оценит утверждение. Если бы мы использовали colorConfig[colors [1]], он бы возвратил значение свойства red объекта colorConfig.

</span>
</div>

---
<div>

###### 107. Чему равно значение?

<section>
console.log('❤️' === '❤️')
</section>


- A: true
- B: false


#### Ответ: A

<span>
Под капотом смайлики - это юникоды. Юникод для сердца смайликов "U+2764 U+FE0F". Они всегда одинаковы для одного и того же смайлика, поэтому мы сравниваем две одинаковые строки друг с другом, что возвращает true.

</span>
</div>

---
<div>

###### 108. Какой из этих методов модифицирует исходный массив?

<section>
const emojis = ['✨', '🥑', '😍']

emojis.map(x => x + '✨')
emojis.filter(x => x !== '🥑')
emojis.find(x => x !== '🥑')
emojis.reduce((acc, cur) => acc + '✨')
emojis.slice(1, 2, '✨') 
emojis.splice(1, 2, '✨')
</section>


- A: All of them
- B: map reduce slice splice
- C: map slice splice 
- D: splice


#### Ответ: D

<span>
Используя метод splice, мы модифицируем исходный массив, удаляя, заменяя или добавляя элементы. В этом случае мы удалили 2 элемента из индекса 1 (мы удалили '🥑' и '😍') и добавили ✨ emoji.

map, filter и slice возвращают новый массив, find возвращает элемент, а reduce возвращает аккумулированное значение.

</span>
</div>

---
<div>

###### <a name=20191009></a>109. Какое значение будет на выходе?

<section>
const food = ['🍕', '🍫', '🥑', '🍔']
const info = { favoriteFood: food[0] }

info.favoriteFood = '🍝'

console.log(food)
</section>


- A: ['🍕', '🍫', '🥑', '🍔']
- B: ['🍝', '🍫', '🥑', '🍔']
- C: ['🍝', '🍕', '🍫', '🥑', '🍔'] 
- D: ReferenceError


#### Ответ: A

<span>
Мы устанавливаем значение свойства favourFood для объекта info равным строке со смайликами для пиццы, '🍕'. Строка является примитивным типом данных. В JavaScript примитивные типы данных передаются по ссылке ...

В JavaScript примитивные типы данных (все, что не является объектом) передаются как _значение_. В этом случае мы устанавливаем значение свойства favourFood объекта info равным значению первого элемента в массиве food, в данном случае это строка с emoji пиццы ('🍕'). Строка является примитивным типом данных и взаимодействует по значению (см. мой [пост в блоге](https://www.theavocoder.com/complete-javascript/2018/12/21/by-value-vs-by-reference), если вы заинтересованы в получении дополнительной информации).

Затем мы меняем значение свойства favourFood объекта info. Массив food не изменился, поскольку значение favourFood было просто _скопировано_ из значения первого элемента в массиве и не имеет ссылки на то же место в памяти, что и элемент на food[0]. Когда мы выводим в лог food, это все равно исходный массив, ['🍕', '🍫', '🥑', '🍔'].

</span>
</div>

---
<div>

###### 110. Что делает этот метод?

<section>
JSON.parse()
</section>


- A: Разбирает JSON в значение JavaScript
- B: Разбирает объект JavaScript в JSON
- C: Разбирает любое значение JavaScript в JSON
- D: Разбирает JSON непосредственно в объект JavaScript


#### Ответ: A

<span>
С помощью метода JSON.parse () мы можем разобрать строку JSON в значение JavaScript.

<section>
// Преобразование числа в допустимый JSON, затем преобразование строки JSON в значение JavaScript:
const jsonNumber = JSON.stringify(4) // '4'
JSON.parse(jsonNumber) // 4

// Преобразование значения массива в допустимый JSON, затем разбор строки JSON в значение JavaScript:
const jsonArray = JSON.stringify([1, 2, 3]) // '[1, 2, 3]'
JSON.parse(jsonArray) // [1, 2, 3]

// Преобразование объекта в допустимый JSON, затем преобразование строки JSON в значение JavaScript:
const jsonArray = JSON.stringify({ name: "Lydia" }) // '{"name":"Lydia"}'
JSON.parse(jsonArray) // { name: 'Lydia' }
</section>

</span>
</div>

---
<div>

###### 111. Какое значение будет на выходе? 

<section>
let name = 'Lydia'

function getName() {
  console.log(name)
  let name = 'Sarah'
}

getName()
</section>


- A: Lydia
- B: Sarah
- C: undefined
- D: ReferenceError


#### Ответ: D

<span>
Каждая функция имеет свой собственный _контекст исполнения_ (или _область действия_). Функция getName сначала ищет в своем собственном контексте (области действия), чтобы увидеть, содержит ли она переменную name, к которой мы пытаемся получить доступ. В этом случае функция getName содержит собственную переменную name: мы объявляем переменную name с ключевым словом let и значением 'Sarah'.

Переменные с ключевым словом let (и const) поднимаются в начало функции, в отличие от var, которые <i>не инициализируется</i>. Они недоступны до того, как мы объявим (инициализируем) их строку. Это называется "временной мертвой зоной". Когда мы пытаемся получить доступ к переменным до их объявления, JavaScript выдает ReferenceError.

Если бы мы не объявили переменную name в функции getName, движок javascript посмотрел бы вниз по _цепочки области действия_. Внешняя область имеет переменную с именем name со значением Lydia. В этом случае он бы записал Lydia.

<section>
let name = 'Lydia'

function getName() {
  console.log(name)
}

getName() // Lydia
</section>

</span>
</div>

---
<div>

###### 112. Какое значение будет на выходе?

<section>
function* generatorOne() {
  yield ['a', 'b', 'c'];
}

function* generatorTwo() {
  yield* ['a', 'b', 'c'];
}

const one = generatorOne()
const two = generatorTwo()

console.log(one.next().value)
console.log(two.next().value)
</section>


- A: a and a
- B: a and undefined
- C: ['a', 'b', 'c'] and a
- D: a and ['a', 'b', 'c']


#### Ответ: C

<span>
Используя ключевое слово yield, мы получаем значения в функции генератора. С помощью ключевого слова yield* мы можем получить значения из другой функции-генератора или итерируемого объекта (например, массива).

В generatorOne мы получаем весь массив ['a', 'b', 'c'], используя ключевое слово yield. Значение свойства value для объекта, возвращаемого методом next для one (one.next().value), равно всему массиву ['a', 'b', 'c'].

<section>
console.log(one.next().value) // ['a', 'b', 'c']
console.log(one.next().value) // undefined
</section>

В файле generatorTwo мы используем ключевое слово yield*. Это означает, что первое полученное значение two равно первому полученному значению в итераторе. Итератор - это массив ['a', 'b', 'c']. Первым полученным значением является a, поэтому в первый раз, когда мы вызываем two.next().value, возвращается a.

<section>
console.log(two.next().value) // 'a'
console.log(two.next().value) // 'b'
console.log(two.next().value) // 'c'
console.log(two.next().value) // undefined
</section>

</span>
</div>

---
<div>

###### 113. Какое значение будет на выходе?

<section>
console.log(${(x => x)('I love')} to program)
</section>


- A: I love to program
- B: undefined to program
- C: ${(x => x)('I love') to program
- D: TypeError


#### Ответ: A

<span>
Выражения внутри литералов шаблона расчитываются первыми. Это означает, что строка будет содержать возвращаемое значение выражения, в данном случае немедленно исполняемую функцию (x => x)('I love'). Мы передаем значение 'I love' в качестве аргумента стрелочной функции x => x. x равно 'I love', которое и возвращается. Это приводит к I love to program.

</span>
</div>

---
<div>

###### 114. Что произойдет?

<section>
let config = {
  alert: setInterval(() => {
    console.log('Alert!')
  }, 1000)
}

config = null
</section>


- A: обратный вызов setInterval не будет вызван
- B: обратный вызов setInterval будет вызван один раз
- C: обратный вызов setInterval будет вызываться каждую секунду
- D: мы никогда не вызовем config.alert(), т.к. config равно null


#### Ответ: C

<span>
Обычно, когда мы устанавливаем объекты равными null, эти объекты получают метку _собрано в мусор_, так как больше нет ссылок на этот объект. Однако, поскольку функция обратного вызова в setInterval является стрелочной функцией (таким образом, привязанной к объекту config), функция обратного вызова все еще содержит ссылку на объект config. Пока есть ссылка, объект не будет собран в мусор. Поскольку сборщик мусора не отрабатывает, функция обратного вызова setInterval будет по-прежнему вызываться каждые 1000 мс (1с).

</span>
</div>

---
<div>

###### 115. Какие методы вернут значение 'Hello world!'?

<section>
const myMap = new Map()
const myFunc = () => 'greeting'

myMap.set(myFunc, 'Hello world!')

//1
myMap.get('greeting')
//2
myMap.get(myFunc)
//3
myMap.get(() => 'greeting')
</section>


- A: 1
- B: 2
- C: 2 и 3
- D: Каждый из них


#### Ответ: B

<span>
При добавлении пары ключ/значение с использованием метода set имя ключа будет равно значению первого аргумента, переданного в функцию set, а значением будет второй аргумент, переданный в функцию set. В данном случае ключом является _функция_ () => 'greeting' и значение 'Hello world'. myMap теперь это { () => 'greeting' => 'Hello world!' }.

1 неверно, поскольку ключ не 'greeting', а () => 'greeting'.
3 неверно, так как мы создаем новую функцию, передавая ее в качестве параметра методу get. Объект взаимодействует со _ссылкой_. Функции - это объекты, поэтому две функции никогда не бывают строго равными, даже если они идентичны: они имеют ссылки на разные места в памяти.

</span>
</div>

---
<div>

###### 116. Какое значение будет на выходе?

<section>
const person = {
  name: "Lydia",
  age: 21
}

const changeAge = (x = { ...person }) => x.age += 1
const changeAgeAndName = (x = { ...person }) => {
  x.age += 1
  x.name = "Sarah"
}

changeAge(person)
changeAgeAndName()

console.log(person)
</section>


- A: {name: "Sarah", age: 22}
- B: {name: "Sarah", age: 23}
- C: {name: "Lydia", age: 22}
- D: {name: "Lydia", age: 23}


#### Ответ: C

<span>
Функции changeAge и changeAgeAndName имеют параметр по умолчанию, а именно _вновь_ созданный объект { ...person }. Этот объект имеет копии всех ключей/значений объекта person.

Сначала мы вызываем функцию changeAge и передаем объект person в качестве аргумента. Эта функция увеличивает значение свойства age на 1. person теперь {name: "Lydia", age: 22}.

Затем мы вызываем функцию changeAgeAndName, однако мы не передаем параметр. Вместо этого значение x равно новому объекту: { ... person }. Поскольку это новый объект, он не влияет на значения свойств объекта person. person по-прежнему равен {name: "Lydia", age: 22}.

</span>
</div>

---
<div>

###### <a name=20191118></a>117. Какой из следующих наборов параметров вернет 6?

<section>
function sumValues(x, y, z) {
	return x + y + z;
}
</section>


- A: sumValues([...1, 2, 3])
- B: sumValues([...[1, 2, 3]])
- C: sumValues(...[1, 2, 3])
- D: sumValues([1, 2, 3])


#### Ответ: C

<span>
С помощью оператора распространения (spread) ... мы можем _распределить_ итерации в отдельньные элементы. sumValues принимает три аргумента:x, y и z. ...[1, 2, 3] приведет к перечню 1, 2, 3, который мы передаем функции sumValues.

</span>
</div>

---
<div>

###### 118. Что будет на выходе?

<section>
let num = 1;
const list = ["🥳", "🤠", "🥰", "🤪"];

console.log(list[(num += 1)]);
</section>


- A: 🤠
- B: 🥰
- C: SyntaxError
- D: ReferenceError


#### Ответ: B

<span>
С операндом += мы увеличиваем значение num на 1. num имеет начальное значение 1, поэтому 1 + 1 равно 2. Элементом второго индекса в массиве list и является вывод console.log (list [2])🥰.

</span>
</div>

---
<div>

###### 119. Что будет на выходе?

<section>
const person = {
	firstName: "Lydia",
	lastName: "Hallie",
	pet: {
		name: "Mara",
		breed: "Dutch Tulip Hound"
	},
	getFullName() {
		return ${this.firstName} ${this.lastName};
	}
};

console.log(person.pet?.name);
console.log(person.pet?.family?.name);
console.log(person.getFullName?.());
console.log(member.getLastName?.());
</section>


- A: undefined undefined undefined undefined
- B: Mara undefined Lydia Hallie undefined
- C: Mara null Lydia Hallie null
- D: null ReferenceError null ReferenceError


#### Ответ: B

<span>
С необязательным оператором связывания ?. нам больше не нужно явно проверять, действительны ли более глубокие вложенные значения или нет. Если мы пытаемся получить доступ к свойству со (_нулевым_) значением undefined или null, выражение замыкается и возвращает undefined.

person.pet?.name: person имеет свойство с именем pet: person.pet не нулевое. Оно имеет свойство с именем name, и возвращает Mara.
person.pet?.family?.name: person имеет свойство с именем pet: person.pet не нулевое. pet _не_ имеет свойство с именем family, person.pet.family нулевое. Выражение возвращает undefined.
person.getFullName?.(): person имеет свойство с именем getFullName: person.getFullName() не нулевое, и может быть вызвано, возвращает Lydia Hallie.
member.getLastName?.(): member не определено: member.getLastName() нулевое. Выражение возвращает undefined.

</span>
</div>

---
<div>

###### 120. Что будет на выходе?

<section>
const groceries = ["banana", "apple", "peanuts"];

if (groceries.indexOf("banana")) {
	console.log("We have to buy bananas!");
} else {
	console.log(We don't have to buy bananas!);
}
</section>


- A: We have to buy bananas!
- B: We don't have to buy bananas
- C: undefined
- D: 1


#### Ответ: B

<span>
Мы передали условие groceries.indexOf("banana") в оператор if. groceries.indexOf("banana") возвращает 0, что является ложным значением. Поскольку условие в операторе if ложно, выполняется код в блоке else, и в лог выводится We don't have to buy bananas!.

</span>
</div>

---
<div>

###### 121. Что будет на выходе?

<section>
const config = {
	languages: [],
	set language(lang) {
		return this.languages.push(lang);
	}
};

console.log(config.language);
</section>


- A: function language(lang) { this.languages.push(lang }
- B: 0
- C: []
- D: undefined


#### Ответ: D

<span>
Метод language является сеттером. Сеттеры не содержат действительного значения, их целью является изменение свойств. При вызове метода setter возвращается undefined.

</span>
</div>

---
<div>

###### 122. Что будет на выходе?

<section>
const name = "Lydia Hallie";

console.log(!typeof name === "object");
console.log(!typeof name === "string");
</section>


- A: false true
- B: true false
- C: false false
- D: true true


#### Ответ: C

<span>
typeof name возвращает "строку". Строка "string" является истинным значением, поэтому !typeof name возвращает логическое значение false. false === "object" и false === "string" оба возвращают false.

(Если бы мы хотели проверить, был ли тип (не)равен определенному типу, мы должны были написать !== вместо !typeof)

</span>
</div>

---
<div>

###### 123. Что будет на выходе?

<section>
const add = x => y => z => {
	console.log(x, y, z);
	return x + y + z;
};

add(4)(5)(6);
</section>


- A: 4 5 6
- B: 6 5 4
- C: 4 function function
- D: undefined undefined 6


#### Ответ: A

<span>
Функция add возвращает стрелочную функцию, которая возвращает стрелочную функцию, которая возвращает стрелочную функцию (все еще тут?). Первая функция получает аргумент x со значением 4. Мы вызываем вторую функцию, которая получает аргумент y со значением 5. Затем мы вызываем третью функцию, которая получает аргумент z со значением 6. Когда мы пытаемся получить доступ к значениям x, y и z в функции последней стрелки, движок JS поднимается вверх по цепочке областей видимости, чтобы найти значения для x и y соответственно. Это возвращает 4 5 6.

</span>
</div>

---
<div>

###### 124. Что будет на выходе?

<section>
async function* range(start, end) {
	for (let i = start; i <= end; i++) {
		yield Promise.resolve(i);
	}
}

(async () => {
	const gen = range(1, 3);
	for await (const item of gen) {
		console.log(item);
	}
})();
</section>


- A: Promise {1} Promise {2} Promise {3}
- B: Promise {<pending>} Promise {<pending>} Promise {<pending>}
- C: 1 2 3
- D: undefined undefined undefined


#### Ответ: C

<span>
Функция генератора range возвращает асинхронный объект с обещаниями для каждого элемента в диапазоне, который мы передаем: Promise {1}, Promise {2}, Promise {3}. Мы устанавливаем переменную gen равной асинхронному объекту, после чего зацикливаем ее, используя цикл for await ... of. Мы устанавливаем переменную item равной возвращаемым значениям Promise: сначала Promise {1}, затем Promise {2}, затем Promise {3}. Так как мы _ожидаем_ значение item, разрешается обещание, возвращаются разрешенные _значения_ обещания: 1, 2, затем 3.

</span>
</div>

---
<div>

###### 125. Что будет на выходе?

<section>
const myFunc = ({ x, y, z }) => {
	console.log(x, y, z);
};

myFunc(1, 2, 3);
</section>


- A: 1 2 3
- B: {1: 1} {2: 2} {3: 3}
- C: { 1: undefined } undefined undefined
- D: undefined undefined undefined


#### Ответ: D

<span>
myFunc ожидает объект со свойствами x, y и z в качестве аргумента. Поскольку мы передаем только три отдельных числовых значения (1, 2, 3) вместо одного объекта со свойствами x, y и z ({x: 1, y: 2, z: 3}), то x, y и z имеют значение по умолчанию undefined.

</span>
</div>

---
<div>

###### 126. Что будет на выходе?

<section>
function getFine(speed, amount) {
  const formattedSpeed = new Intl.NumberFormat({
    'en-US',
    { style: 'unit', unit: 'mile-per-hour' }
  }).format(speed)

  const formattedAmount = new Intl.NumberFormat({
    'en-US',
    { style: 'currency', currency: 'USD' }
  }).format(amount)

  return The driver drove ${formattedSpeed} and has to pay ${formattedAmount}
}

console.log(getFine(130, 300))
</section>


- A: The driver drove 130 and has to pay 300
- B: The driver drove 130 mph and has to pay \$300.00
- C: The driver drove undefined and has to pay undefined
- D: The driver drove 130.00 and has to pay 300.00


#### Ответ: B

<span>
С помощью метода Intl.NumberFormat мы можем форматировать числовые значения в любой локали. Мы форматируем числовое значение 130 для локали en-US как unit в mile-per-hour, что приводит к 130 mph. Числовое значение 300 для локали en-US в качестве currentcy в USD приводит к $300.00.

</span>
</div>

---
<div>

###### 127. Что будет на выходе?

<section>
const spookyItems = ["👻", "🎃", "🕸"];
({ item: spookyItems[3] } = { item: "💀" });

console.log(spookyItems);
</section>


- A: ["👻", "🎃", "🕸"]
- B: ["👻", "🎃", "🕸", "💀"]
- C: ["👻", "🎃", "🕸", { item: "💀" }]
- D: ["👻", "🎃", "🕸", "[object Object]"]


#### Ответ: B

<span>
Деструктурируя объекты, мы можем распаковать значения из правого объекта и присвоить распакованному значению значение того же по имени свойства в левом объекте. В этом случае мы присваиваем значение "💀" spookyItems[3]. Это означает, что мы модифицируем массив spookyItems, добавляем к нему «💀». При логировании spookyItems выводится  ["👻", "🎃", "🕸", "💀"].

</span>
</div>

---
<div>

###### 128. Что будет на выходе?

<section>
const name = "Lydia Hallie";
const age = 21;

console.log(Number.isNaN(name));
console.log(Number.isNaN(age));

console.log(isNaN(name));
console.log(isNaN(age));
</section>


- A: true false true false
- B: true false false false
- C: false false true false
- D: false true false true


#### Ответ: C

<span>
С помощью метода Number.isNaN вы можете проверить, является ли передаваемое вами значение _числовым значением_ и равно ли оно NaN. name не является числовым значением, поэтому Number.isNaN(name) возвращает false. age является числовым значением, но не равно NaN, поэтому Number.isNaN(age) возвращает false.

С помощью метода isNaN вы можете проверить, не является ли передаваемое вами значение числом. name не является числом, поэтому isNaN(name) возвращает true. age - это число, поэтому isNaN(age) возвращает false.

</span>
</div>

---
<div>

###### 129. Что будет на выходе?

<section>
const randomValue = 21;

function getInfo() {
	console.log(typeof randomValue);
	const randomValue = "Lydia Hallie";
}

getInfo();
</section>


- A: "number"
- B: "string"
- C: undefined
- D: ReferenceError


#### Ответ: D

<span>
Переменные, объявленные с ключевым словом const, не имеют ссылки до их инициализации: это называется _временная мертвая зона_. В функции getInfo переменная randomValue находится в области видимости getInfo. В строке, где мы хотим записать значение typeof randomValue, переменная randomValue еще не инициализирована: выдается ReferenceError! Движок не пошел по цепочке областей видимости, так как мы объявили переменную randomValue в функции getInfo.

</span>
</div>

---
<div>

###### 130. Что будет на выходе?

<section>
const myPromise = Promise.resolve("Woah some cool data");

(async () => {
	try {
		console.log(await myPromise);
	} catch {
		throw new Error(Oops didn't work);
	} finally {
		console.log("Oh finally!");
	}
})();
</section>


- A: Woah some cool data
- B: Oh finally!
- C: Woah some cool data Oh finally!
- D: Oops didn't work Oh finally!


#### Ответ: C

<span>
В блоке try мы выводим в лог ожидаемое значение переменной myPromise: "Woah some cool data". Поскольку в блоке try не было выдано никаких ошибок, код в блоке catch не запускается. Код в блоке finally _всегда_ выполняется, "Oh finally!" также выводится в лог.

</span>
</div>

---
<div>

###### 131. Что будет на выходе?

<section>
const emojis = ["🥑", ["✨", "✨", ["🍕", "🍕"]]];

console.log(emojis.flat(1));
</section>


- A: ['🥑', ['✨', '✨', ['🍕', '🍕']]]
- B: ['🥑', '✨', '✨', ['🍕', '🍕']]
- C: ['🥑', ['✨', '✨', '🍕', '🍕']]
- D: ['🥑', '✨', '✨', '🍕', '🍕']


#### Ответ: B

<span>
С помощью метода flat мы можем создать новый плоский массив. Глубина уплощенного массива зависит от значения, которое мы передаем. В этом случае мы передали значение 1 (которое нам не нужно, это значение по умолчанию), что означает, что будут объединены только массивы на первой глубине. ['🥑'] и ['✨', '✨', ['🍕', '🍕']] в этом случае. Конкатенация этих двух массивов приводит к ['🥑', '✨', '✨', ['🍕', '🍕']].

</span>
</div>

---
<div>

###### 132. Что будет на выходе?

<section>
class Counter {
  constructor() {
    this.count = 0;
  }

  increment() {
    this.count++;
  }
}

const counterOne = new Counter();
counterOne.increment();
counterOne.increment();

const counterTwo = counterOne;
counterTwo.increment();

console.log(counterOne.count);
</section>


- A: 0
- B: 1
- C: 2
- D: 3


#### Ответ: D

<span>
counterOne экземпляр класса Counter. Counter класс содержит метод increment и свойство count в конструкторе. Сперва, при помощи counterOne.increment(), мы дважды вызываем метод increment. counterOne.count становится 2.

<img src="https://i.imgur.com/KxLlTm9.png" width="400">

Затем, мы создаем новую переменную counterTwo, и присваиваем ей counterOne. Поскольку объекты передаются по ссылке, мы просто создаем новую ссылку на то же место в памяти, на которое указывает counterOne. Поскольку переменные ссылаются на то же место в памяти, любые изменения, внесенные в объект, на который ссылается counterTwo, также применяются к counterOne. Теперь counterTwo.count равно 2.

Мы вызываем counterTwo.increment(), что устанавливает значение count равное 3. Затем мы выводим в консоль значение переменной counterOne, которое равно 3.

<img src="https://i.imgur.com/BNBHXmc.png" width="400">

</span>
</div>

---
<div>

###### 133. Что будет на выходе?

<section>
const myPromise = Promise.resolve(Promise.resolve('Promise!'));

function funcOne() {
  myPromise.then(res => res).then(res => console.log(res));
  setTimeout(() => console.log('Timeout!', 0));
  console.log('Last line!');
}

async function funcTwo() {
  const res = await myPromise;
  console.log(await res);
  setTimeout(() => console.log('Timeout!', 0));
  console.log('Last line!');
}

funcOne();
funcTwo();
</section>


- A: Promise! Last line! Promise! Last line! Last line! Promise!
- B: Last line! Timeout! Promise! Last line! Timeout! Promise!
- C: Promise! Last line! Last line! Promise! Timeout! Timeout!
- D: Last line! Promise! Promise! Last line! Timeout! Timeout!


#### Ответ: D

<span>
Сначала мы вызываем функцию funcOne. В первой строке funcOne происходит вызов обещания myPromise, которое является _асинхронной_ операцией. Пока движок занят обработкой обещания, он продолжает выполнение функции funcOne. Следующая строка является _асинхронной_ функцией setTimeout, поэтому её обратный вызов будет отправлен в Web API. (см. мою статью о цикле событий [здесь](https://dev.to/lydiahallie/javascript-visualized-event-loop-3dif).)

Обещание, как и таймер, является асинхронной операцией, поэтому функция продолжит выполняться несмотря на обработку обещания и обратного вызова setTimeout. Выходит так, что Last line! попадет в консоль первой, т.к. не является асинхронной операцией. Далее, в следующей строке funcOne, обещание будет выполнено и Promise! выводится в консоль. Однако, т.к. далее мы вызываем funcTwo(), стэк вызывов не будет пустым, из-за чего обратный вызов функции setTimeout _пока_ не будет добавлен в стэк вызовов.

В первой строке funcTwo мы _ожидаем_ выполнения обещания myPromise. С помощью ключевого слова await мы приостанавливаем выполнение функции пока обещание не будет выполнено (или отклонено). Затем выводим в консоль _ожидаемое_ значение res (т.к. предыдущее обещание вернуло обещание). После чего в консоль попадает Promise!.

Следующая строка является _асинхронной_ функцией setTimeout, которая отправляет обратный вызов в Web API.

Мы перешли к следующей строке функции funcTwo которая выводит в консоль Last line!. Теперь, когда стэк вызовов извлечен из funcTwo, он становится пустым. Обратные вызовы, которые ожидали очереди (() => console.log("Timeout!") из funcOne, и () => console.log("Timeout!") из funcTwo) добавлены в стэк вызовов один за другим. Первый вызов выведет в консоль Timeout! и будет извлечен из стэка. Следующий вызов также выведет Timeout! и тоже будет извлечен из стэка вызовов. Лог будет равен Last line! Promise! Promise! Last line! Timeout! Timeout!

</span>
</div>

---
<div>

###### 134. Как мы можем вызвать функцию sum в sum.js из index.js?

<section>
// sum.js
export default function sum(x) {
  return x + x;
}

// index.js
import * as sum from './sum';
</section>


- A: sum(4)
- B: sum.sum(4)
- C: sum.default(4)
- D: Нельзя импортировать значения по умолчанию используя *, только именованные экспорты


#### Ответ: C

<span>
Используя звездочку *, мы импортируем все экспортируемые значения из файла, включая именнованные экспорты и экспорты по умолчанию. Если бы у нас был следующий файл:

<section>
// info.js
export const name = 'Lydia';
export const age = 21;
export default 'I love JavaScript';

// index.js
import * as info from './info';
console.log(info);
</section>

В лог попадёт следующее:

<section>
{
  default: "I love JavaScript",
  name: "Lydia",
  age: 21
}
</section>

Для примера sum это означает, что импортированное значение sum будет таким:

<section>
{ default: function sum(x) { return x + x } }
</section>

Следовательно, мы можем вызвать эту функцию используя sum.default

</span>
</div>

---
<div>

###### 135. Что будет на выходе?

<section>
const handler = {
  set: () => console.log('Added a new property!'),
  get: () => console.log('Accessed a property!'),
};

const person = new Proxy({}, handler);

person.name = 'Lydia';
person.name;
</section>


- A: Added a new property!
- B: Accessed a property!
- C: Added a new property! Accessed a property!
- D: В лог ничего не попадёт


#### Ответ: C

<span>
C помощью Proxy мы можем добавить собственное поведению объекту, которое мы передаем вторым аргументом. В нашем случае мы передаем объект handler который содержит свойства: set и get. set вызывается каждый раз когда мы _устанавливаем_ значения свойств, get же вызывается всякий раз когда мы _получаем_ значения свойств.

Первый аргумент — пустой объект {}, который является значением person. Для него будет добавлено собственное поведение, описанное в объекте handler. При добавлении значения для объекта person будет вызвано свойство set. При запросе к значению person вызовется свойство get.

Сначала мы устанавливаем новое свойство name для объекта Proxy (person.name = "Lydia"). Вызывается set и в лог попадает "Added a new property!".

Затем мы обращаемся к значению Proxy-объекта. Вызывается свойство get объекта handler. "Accessed a property!" попадает в лог.

</span>
</div>

---
<div>

###### 136. Какое из перечисленных действий может модифицировать объект person?

<section>
const person = { name: 'Lydia Hallie' };

Object.seal(person);
</section>


- A: person.name = "Evan Bacon"
- B: person.age = 21
- C: delete person.name
- D: Object.assign(person, { age: 21 })


#### Ответ: A

<span>
С помощью Object.seal мы можем предотвращать как _добавление_ новых свойств, так и _удаление_ существующих.

Однако, изменение существующих свойств остаётся доступным.

</span>
</div>

---
<div>

###### 137. Какое из перечисленных действий может модифицировать объект person?

<section>
const person = {
  name: 'Lydia Hallie',
  address: {
    street: '100 Main St',
  },
};

Object.freeze(person);
</section>


- A: person.name = "Evan Bacon"
- B: delete person.address
- C: person.address.street = "101 Main St"
- D: person.pet = { name: "Mara" }


#### Ответ: C

<span>
С помощью метода Object.freeze мы можем _заморозить_ объект. Свойства не могут быть добавлены, изменены или удалены.

Однако, это _неглубоко_ замораживает объект. Замораживаются только _непосредственные_ свойства объекта. Если свойством является другой объект(в нашем примере address), свойства этого объекта не замораживаются и могут быть изменены.

</span>
</div>
